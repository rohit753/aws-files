.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DateTime 3pm"
.TH DateTime 3pm "2022-04-18" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DateTime \- A date and time object for Perl
.SH "VERSION"
.IX Header "VERSION"
version 1.58
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use DateTime;
\&
\&    $dt = DateTime\->new(
\&        year       => 1964,
\&        month      => 10,
\&        day        => 16,
\&        hour       => 16,
\&        minute     => 12,
\&        second     => 47,
\&        nanosecond => 500000000,
\&        time_zone  => \*(AqAsia/Taipei\*(Aq,
\&    );
\&
\&    $dt = DateTime\->from_epoch( epoch => $epoch );
\&    $dt = DateTime\->now;    # same as ( epoch => time )
\&
\&    $year  = $dt\->year;
\&    $month = $dt\->month;        # 1\-12
\&
\&    $day = $dt\->day;            # 1\-31
\&
\&    $dow = $dt\->day_of_week;    # 1\-7 (Monday is 1)
\&
\&    $hour   = $dt\->hour;        # 0\-23
\&    $minute = $dt\->minute;      # 0\-59
\&
\&    $second = $dt\->second;      # 0\-61 (leap seconds!)
\&
\&    $doy = $dt\->day_of_year;    # 1\-366 (leap years)
\&
\&    $doq = $dt\->day_of_quarter; # 1..
\&
\&    $qtr = $dt\->quarter;        # 1\-4
\&
\&    # all of the start\-at\-1 methods above have corresponding start\-at\-0
\&    # methods, such as $dt\->day_of_month_0, $dt\->month_0 and so on
\&
\&    $ymd = $dt\->ymd;         # 2002\-12\-06
\&    $ymd = $dt\->ymd(\*(Aq/\*(Aq);    # 2002/12/06
\&
\&    $mdy = $dt\->mdy;         # 12\-06\-2002
\&    $mdy = $dt\->mdy(\*(Aq/\*(Aq);    # 12/06/2002
\&
\&    $dmy = $dt\->dmy;         # 06\-12\-2002
\&    $dmy = $dt\->dmy(\*(Aq/\*(Aq);    # 06/12/2002
\&
\&    $hms = $dt\->hms;         # 14:02:29
\&    $hms = $dt\->hms(\*(Aq!\*(Aq);    # 14!02!29
\&
\&    $is_leap = $dt\->is_leap_year;
\&
\&    # these are localizable, see Locales section
\&    $month_name = $dt\->month_name;    # January, February, ...
\&    $month_abbr = $dt\->month_abbr;    # Jan, Feb, ...
\&    $day_name   = $dt\->day_name;      # Monday, Tuesday, ...
\&    $day_abbr   = $dt\->day_abbr;      # Mon, Tue, ...
\&
\&    # May not work for all possible datetime, see the docs on this
\&    # method for more details.
\&    $epoch_time = $dt\->epoch;
\&
\&    $dt2 = $dt + $duration_object;
\&
\&    $dt3 = $dt \- $duration_object;
\&
\&    $duration_object = $dt \- $dt2;
\&
\&    $dt\->set( year => 1882 );
\&
\&    $dt\->set_time_zone(\*(AqAmerica/Chicago\*(Aq);
\&
\&    $dt\->set_formatter($formatter);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DateTime is a class for the representation of date/time combinations, and is
part of the Perl DateTime project.
.PP
It represents the Gregorian calendar, extended backwards in time before its
creation (in 1582). This is sometimes known as the \*(L"proleptic Gregorian
calendar\*(R". In this calendar, the first day of the calendar (the epoch), is the
first day of year 1, which corresponds to the date which was (incorrectly)
believed to be the birth of Jesus Christ.
.PP
The calendar represented does have a year 0, and in that way differs from how
dates are often written using \*(L"\s-1BCE/CE\*(R"\s0 or \*(L"\s-1BC/AD\*(R".\s0
.PP
For infinite datetimes, please see the DateTime::Infinite
module.
.SH "USAGE"
.IX Header "USAGE"
.SS "0\-based Versus 1\-based Numbers"
.IX Subsection "0-based Versus 1-based Numbers"
The \f(CW\*(C`DateTime\*(C'\fR module follows a simple logic for determining whether or not a
given number is 0\-based or 1\-based.
.PP
Month, day of month, day of week, and day of year are 1\-based. Any method that
is 1\-based also has an equivalent 0\-based method ending in \f(CW\*(C`_0\*(C'\fR. So for
example, this class provides both \f(CW\*(C`day_of_week\*(C'\fR and \f(CW\*(C`day_of_week_0\*(C'\fR methods.
.PP
The \f(CW\*(C`day_of_week_0\*(C'\fR method still treats Monday as the first day of the week.
.PP
All \fItime\fR\-related numbers such as hour, minute, and second are 0\-based.
.PP
Years are neither, as they can be both positive or negative, unlike any other
datetime component. There \fIis\fR a year 0.
.PP
There is no \f(CW\*(C`quarter_0\*(C'\fR method.
.SS "Error Handling"
.IX Subsection "Error Handling"
Some errors may cause this module to die with an error string. This can only
happen when calling constructor methods, methods that change the object, such
as \f(CW\*(C`set\*(C'\fR, or methods that take parameters. Methods that retrieve information
about the object, such as \f(CW\*(C`year\*(C'\fR or \f(CW\*(C`epoch\*(C'\fR, will never die.
.SS "Locales"
.IX Subsection "Locales"
All the object methods which return names or abbreviations return data based on
a locale. This is done by setting the locale when constructing a DateTime
object. If this is not set, then \f(CW"en\-US"\fR is used.
.SS "Floating DateTimes"
.IX Subsection "Floating DateTimes"
The default time zone for new DateTime objects, except where stated otherwise,
is the \*(L"floating\*(R" time zone. This concept comes from the iCal standard. A
floating datetime is one which is not anchored to any particular time zone. In
addition, floating datetimes do not include leap seconds, since we cannot apply
them without knowing the datetime's time zone.
.PP
The results of date math and comparison between a floating datetime and one
with a real time zone are not really valid, because one includes leap seconds
and the other does not. Similarly, the results of datetime math between two
floating datetimes and two datetimes with time zones are not really comparable.
.PP
If you are planning to use any objects with a real time zone, it is strongly
recommended that you \fBdo not\fR mix these with floating datetimes.
.SS "Math"
.IX Subsection "Math"
If you are going to be doing date math, please read the section \*(L"How DateTime
Math Works\*(R".
.SS "Determining the Local Time Zone Can Be Slow"
.IX Subsection "Determining the Local Time Zone Can Be Slow"
If \f(CW$ENV{TZ}\fR is not set, it may involve reading a number of files in \fI/etc\fR
or elsewhere. If you know that the local time zone won't change while your code
is running, and you need to make many objects for the local time zone, it is
strongly recommended that you retrieve the local time zone once and cache it:
.PP
.Vb 1
\&    our $App::LocalTZ = DateTime::TimeZone\->new( name => \*(Aqlocal\*(Aq );
\&
\&    # then everywhere else
\&
\&    my $dt = DateTime\->new( ..., time_zone => $App::LocalTZ );
.Ve
.PP
DateTime itself does not do this internally because local time zones can
change, and there's no good way to determine if it's changed without doing all
the work to look it up.
.SS "Far Future \s-1DST\s0"
.IX Subsection "Far Future DST"
Do not try to use named time zones (like \*(L"America/Chicago\*(R") with dates very far
in the future (thousands of years). The current implementation of
\&\f(CW\*(C`DateTime::TimeZone\*(C'\fR will use a huge amount of memory calculating all the \s-1DST\s0
changes from now until the future date. Use \s-1UTC\s0 or the floating time zone and
you will be safe.
.SS "Globally Setting a Default Time Zone"
.IX Subsection "Globally Setting a Default Time Zone"
\&\fBWarning: This is very dangerous. Do this at your own risk!\fR
.PP
By default, \f(CW\*(C`DateTime\*(C'\fR uses either the floating time zone or \s-1UTC\s0 for newly
created objects, depending on the constructor.
.PP
You can force \f(CW\*(C`DateTime\*(C'\fR to use a different time zone by setting the
\&\f(CW\*(C`PERL_DATETIME_DEFAULT_TZ\*(C'\fR environment variable.
.PP
As noted above, this is very dangerous, as it affects all code that creates a
\&\f(CW\*(C`DateTime\*(C'\fR object, including modules from \s-1CPAN.\s0 If those modules expect the
normal default, then setting this can cause confusing breakage or subtly broken
data. Before setting this variable, you are strongly encouraged to audit your
\&\s-1CPAN\s0 dependencies to see how they use \f(CW\*(C`DateTime\*(C'\fR. Try running the test suite
for each dependency with this environment variable set before using this in
production.
.SS "Upper and Lower Bounds"
.IX Subsection "Upper and Lower Bounds"
Internally, dates are represented the number of days before or after
0001\-01\-01. This is stored as an integer, meaning that the upper and lower
bounds are based on your Perl's integer size (\f(CW$Config{ivsize}\fR).
.PP
The limit on 32\-bit systems is around 2^29 days, which gets you to year
(+/\-)1,469,903. On a 64\-bit system you get 2^62 days, to year
(+/\-)12,626,367,463,883,278 (12.626 quadrillion).
.SH "METHODS"
.IX Header "METHODS"
DateTime provides many methods. The documentation breaks them down into groups
based on what they do (constructor, accessors, modifiers, etc.).
.SS "Constructors"
.IX Subsection "Constructors"
All constructors can die when invalid parameters are given.
.PP
\fIWarnings\fR
.IX Subsection "Warnings"
.PP
Currently, constructors will warn if you try to create a far future DateTime
(year >= 5000) with any time zone besides floating or \s-1UTC.\s0 This can be very
slow if the time zone has future \s-1DST\s0 transitions that need to be calculated. If
the date is sufficiently far in the future this can be \fIreally\fR slow
(minutes).
.PP
All warnings from DateTime use the \f(CW\*(C`DateTime\*(C'\fR category and can be suppressed
with:
.PP
.Vb 1
\&    no warnings \*(AqDateTime\*(Aq;
.Ve
.PP
This warning may be removed in the future if DateTime::TimeZone is made much
faster.
.PP
\fIDateTime\->new( ... )\fR
.IX Subsection "DateTime->new( ... )"
.PP
.Vb 10
\&    my $dt = DateTime\->new(
\&        year       => 1966,
\&        month      => 10,
\&        day        => 25,
\&        hour       => 7,
\&        minute     => 15,
\&        second     => 47,
\&        nanosecond => 500000000,
\&        time_zone  => \*(AqAmerica/Chicago\*(Aq,
\&    );
.Ve
.PP
This class method accepts the following parameters:
.IP "\(bu" 4
year
.Sp
An integer year for the DateTime. This can be any integer number within the
valid range for your system (See \*(L"Upper and Lower Bounds\*(R"). This is required.
.IP "\(bu" 4
month
.Sp
An integer from 1\-12. Defaults to 1.
.IP "\(bu" 4
day
.Sp
An integer from 1\-31. The value will be validated based on the month, to
prevent creating invalid dates like February 30. Defaults to 1.
.IP "\(bu" 4
hour
.Sp
An integer from 0\-23. Hour 0 is midnight at the beginning of the given date.
Defaults to 0.
.IP "\(bu" 4
minute
.Sp
An integer from 0\-59. Defaults to 0.
.IP "\(bu" 4
second
.Sp
An integer from 0\-61. Values of 60 or 61 are only allowed when the specified
date and time have a leap second. Defaults to 0.
.IP "\(bu" 4
nanosecond
.Sp
An integer that is greater than or equal to 0. If this number is greater than 1
billion, it will be normalized into the second value for the DateTime object.
Defaults to 0
.IP "\(bu" 4
locale
.Sp
A string containing a locale code, like \f(CW"en\-US"\fR or \f(CW"zh\-Hant\-TW"\fR, or an
object returned by \f(CW\*(C`DateTime::Locale\->load\*(C'\fR. See the DateTime::Locale
documentation for details. Defaults to the value of \f(CW\*(C`DateTime\->DefaultLocale\*(C'\fR, or \f(CW"en\-US"\fR if the class default has not been set.
.IP "\(bu" 4
time_zone
.Sp
A string containing a time zone name like \*(L"America/Chicago\*(R" or a
DateTime::TimeZone object. Defaults to the value of
\&\f(CW$ENV{PERL_DATETIME_DEFAULT_TZ}\fR or \*(L"floating\*(R" if that env var is not set. See
\&\*(L"Globally Setting a Default Time Zone\*(R" for more details on that env var (and
why you should not use it).
.Sp
A string will simply be passed to the \f(CW\*(C`DateTime::TimeZone\->new\*(C'\fR method as
its \f(CW\*(C`name\*(C'\fR parameter. This string may be an Olson \s-1DB\s0 time zone name
(\*(L"America/Chicago\*(R"), an offset string (\*(L"+0630\*(R"), or the words \*(L"floating\*(R" or
\&\*(L"local\*(R". See the \f(CW\*(C`DateTime::TimeZone\*(C'\fR documentation for more details.
.IP "\(bu" 4
formatter
.Sp
An object or class name with a \f(CW\*(C`format_datetime\*(C'\fR method. This will be used to
stringify the DateTime object. This is optional. If it is not specified, then
stringification calls \f(CW\*(C`$self\->iso8601\*(C'\fR.
.PP
Invalid parameter types (like an array reference) will cause the constructor to
die.
.PP
Parsing Dates
.IX Subsection "Parsing Dates"
.PP
\&\fBThis module does not parse dates!\fR That means there is no constructor to
which you can pass things like \*(L"March 3, 1970 12:34\*(R".
.PP
Instead, take a look at the various
DateTime::Format::* <https://metacpan.org/search?q=datetime%3A%3Aformat>
modules on \s-1CPAN.\s0 These parse all sorts of different date formats, and you're
bound to find something that can handle your particular needs.
.PP
Ambiguous Local Times
.IX Subsection "Ambiguous Local Times"
.PP
Because of Daylight Saving Time, it is possible to specify a local time that is
ambiguous. For example, in the \s-1US\s0 in 2003, the transition from to saving to
standard time occurred on October 26, at 02:00:00 local time. The local clock
changed from 01:59:59 (saving time) to 01:00:00 (standard time). This means
that the hour from 01:00:00 through 01:59:59 actually occurs twice, though the
\&\s-1UTC\s0 time continues to move forward.
.PP
If you specify an ambiguous time, then the latest \s-1UTC\s0 time is always used, in
effect always choosing standard time. In this case, you can simply subtract an
hour from the object in order to move to saving time, for example:
.PP
.Vb 10
\&    # This object represent 01:30:00 standard time
\&    my $dt = DateTime\->new(
\&        year      => 2003,
\&        month     => 10,
\&        day       => 26,
\&        hour      => 1,
\&        minute    => 30,
\&        second    => 0,
\&        time_zone => \*(AqAmerica/Chicago\*(Aq,
\&    );
\&
\&    print $dt\->hms;    # prints 01:30:00
\&
\&    # Now the object represent 01:30:00 saving time
\&    $dt\->subtract( hours => 1 );
\&
\&    print $dt\->hms;    # still prints 01:30:00
.Ve
.PP
Alternately, you could create the object with the \s-1UTC\s0 time zone and then call
the \f(CW\*(C`set_time_zone\*(C'\fR method to change the time zone. This is a good way to
ensure that the time is not ambiguous.
.PP
Invalid Local Times
.IX Subsection "Invalid Local Times"
.PP
Another problem introduced by Daylight Saving Time is that certain local times
just do not exist. For example, in the \s-1US\s0 in 2003, the transition from standard
to saving time occurred on April 6, at the change to 2:00:00 local time. The
local clock changed from 01:59:59 (standard time) to 03:00:00 (saving time).
This means that there is no 02:00:00 through 02:59:59 on April 6!
.PP
Attempting to create an invalid time currently causes a fatal error.
.PP
\fIDateTime\->from_epoch( epoch => \f(CI$epoch\fI, ... )\fR
.IX Subsection "DateTime->from_epoch( epoch => $epoch, ... )"
.PP
This class method can be used to construct a new DateTime object from an epoch
time instead of components. Just as with the \f(CW\*(C`new\*(C'\fR method, it accepts
\&\f(CW\*(C`time_zone\*(C'\fR, \f(CW\*(C`locale\*(C'\fR, and \f(CW\*(C`formatter\*(C'\fR parameters.
.PP
You can also call it with a single unnamed argument, which will be treated as
the epoch value.
.PP
If the epoch value is a non-integral value, it will be rounded to nearest
microsecond.
.PP
By default, the returned object will be in the \s-1UTC\s0 time zone.
.PP
If you pass a \f(CW\*(C`time_zone\*(C'\fR, then this time zone will be applied \fIafter\fR the
object is constructed. In other words, the epoch value is always interpreted
as being in the \s-1UTC\s0 time zone. Here's an example:
.PP
.Vb 7
\&    my $dt = DateTime\->from_epoch(
\&        epoch     => 0,
\&        time_zone => \*(AqAsia/Tokyo\*(Aq
\&    );
\&    say $dt; # Prints 1970\-01\-01T09:00:00 as Asia/Tokyo is +09:00 from UTC.
\&    $dt\->set_time_zone(\*(AqUTC\*(Aq);
\&    say $dt; # Prints 1970\-01\-01T00:00:00
.Ve
.PP
\fIDateTime\->now( ... )\fR
.IX Subsection "DateTime->now( ... )"
.PP
This class method is equivalent to calling \f(CW\*(C`from_epoch\*(C'\fR with the value
returned from Perl's \f(CW\*(C`time\*(C'\fR function. Just as with the \f(CW\*(C`new\*(C'\fR method, it
accepts \f(CW\*(C`time_zone\*(C'\fR and \f(CW\*(C`locale\*(C'\fR parameters.
.PP
By default, the returned object will be in the \s-1UTC\s0 time zone.
.PP
If you want sub-second resolution, use the DateTime::HiRes module's \f(CW\*(C`DateTime::HiRes\->now\*(C'\fR method instead.
.PP
\fIDateTime\->today( ... )\fR
.IX Subsection "DateTime->today( ... )"
.PP
This class method is equivalent to:
.PP
.Vb 1
\&    DateTime\->now(@_)\->truncate( to => \*(Aqday\*(Aq );
.Ve
.PP
\fIDateTime\->last_day_of_month( ... )\fR
.IX Subsection "DateTime->last_day_of_month( ... )"
.PP
This constructor takes the same arguments as can be given to the \f(CW\*(C`new\*(C'\fR method,
except for \f(CW\*(C`day\*(C'\fR. Additionally, both \f(CW\*(C`year\*(C'\fR and \f(CW\*(C`month\*(C'\fR are required.
.PP
\fIDateTime\->from_day_of_year( ... )\fR
.IX Subsection "DateTime->from_day_of_year( ... )"
.PP
This constructor takes the same arguments as can be given to the \f(CW\*(C`new\*(C'\fR method,
except that it does not accept a \f(CW\*(C`month\*(C'\fR or \f(CW\*(C`day\*(C'\fR argument. Instead, it
requires both \f(CW\*(C`year\*(C'\fR and \f(CW\*(C`day_of_year\*(C'\fR. The day of year must be between 1 and
366, and 366 is only allowed for leap years.
.PP
\fIDateTime\->from_object( object => \f(CI$object\fI, ... )\fR
.IX Subsection "DateTime->from_object( object => $object, ... )"
.PP
This class method can be used to construct a new DateTime object from any
object that implements the \f(CW\*(C`utc_rd_values\*(C'\fR method. All \f(CW\*(C`DateTime::Calendar\*(C'\fR
modules must implement this method in order to provide cross-calendar
compatibility. This method accepts a \f(CW\*(C`locale\*(C'\fR and \f(CW\*(C`formatter\*(C'\fR parameter
.PP
If the object passed to this method has a \f(CW\*(C`time_zone\*(C'\fR method, that is used to
set the time zone of the newly created \f(CW\*(C`DateTime\*(C'\fR object.
.PP
Otherwise, the returned object will be in the floating time zone.
.PP
\fI\f(CI$dt\fI\->clone\fR
.IX Subsection "$dt->clone"
.PP
This object method returns a new object that is replica of the object upon
which the method is called.
.ie n .SS """Get"" Methods"
.el .SS "``Get'' Methods"
.IX Subsection "Get Methods"
This class has many methods for retrieving information about an object.
.PP
\fI\f(CI$dt\fI\->year\fR
.IX Subsection "$dt->year"
.PP
Returns the year.
.PP
\fI\f(CI$dt\fI\->ce_year\fR
.IX Subsection "$dt->ce_year"
.PP
Returns the year according to the \s-1BCE/CE\s0 numbering system. The year before year
1 in this system is year \-1, aka \*(L"1 \s-1BCE\*(R".\s0
.PP
\fI\f(CI$dt\fI\->era_name\fR
.IX Subsection "$dt->era_name"
.PP
Returns the long name of the current era, something like \*(L"Before Christ\*(R". See
the \*(L"Locales\*(R" section for more details.
.PP
\fI\f(CI$dt\fI\->era_abbr\fR
.IX Subsection "$dt->era_abbr"
.PP
Returns the abbreviated name of the current era, something like \*(L"\s-1BC\*(R".\s0 See the
\&\*(L"Locales\*(R" section for more details.
.PP
\fI\f(CI$dt\fI\->christian_era\fR
.IX Subsection "$dt->christian_era"
.PP
Returns a string, either \*(L"\s-1BC\*(R"\s0 or \*(L"\s-1AD\*(R",\s0 according to the year.
.PP
\fI\f(CI$dt\fI\->secular_era\fR
.IX Subsection "$dt->secular_era"
.PP
Returns a string, either \*(L"\s-1BCE\*(R"\s0 or \*(L"\s-1CE\*(R",\s0 according to the year.
.PP
\fI\f(CI$dt\fI\->year_with_era\fR
.IX Subsection "$dt->year_with_era"
.PP
Returns a string containing the year immediately followed by the appropriate
era abbreviation, based on the object's locale. The year is the absolute value
of \f(CW\*(C`ce_year\*(C'\fR, so that year 1 is \*(L"1\*(R" and year 0 is \*(L"1BC\*(R". See the \*(L"Locales\*(R"
section for more details.
.PP
\fI\f(CI$dt\fI\->year_with_christian_era\fR
.IX Subsection "$dt->year_with_christian_era"
.PP
Like \f(CW\*(C`year_with_era\*(C'\fR, but uses the \f(CW\*(C`christian_era\*(C'\fR method to get the era
name.
.PP
\fI\f(CI$dt\fI\->year_with_secular_era\fR
.IX Subsection "$dt->year_with_secular_era"
.PP
Like \f(CW\*(C`year_with_era\*(C'\fR, but uses the \f(CW\*(C`secular_era\*(C'\fR method to get the era name.
.PP
\fI\f(CI$dt\fI\->month\fR
.IX Subsection "$dt->month"
.PP
Returns the month of the year, from 1..12.
.PP
Also available as \f(CW\*(C`$dt\->mon\*(C'\fR.
.PP
\fI\f(CI$dt\fI\->month_name\fR
.IX Subsection "$dt->month_name"
.PP
Returns the name of the current month. See the \*(L"Locales\*(R" section for more
details.
.PP
\fI\f(CI$dt\fI\->month_abbr\fR
.IX Subsection "$dt->month_abbr"
.PP
Returns the abbreviated name of the current month. See the \*(L"Locales\*(R" section
for more details.
.PP
\fI\f(CI$dt\fI\->day\fR
.IX Subsection "$dt->day"
.PP
Returns the day of the month, from 1..31.
.PP
Also available as \f(CW\*(C`$dt\->mday\*(C'\fR and \f(CW\*(C`$dt\->day_of_month\*(C'\fR.
.PP
\fI\f(CI$dt\fI\->day_of_week\fR
.IX Subsection "$dt->day_of_week"
.PP
Returns the day of the week as a number, from 1..7, with 1 being Monday and 7
being Sunday.
.PP
Also available as \f(CW\*(C`$dt\->wday\*(C'\fR and \f(CW\*(C`$dt\->dow\*(C'\fR.
.PP
\fI\f(CI$dt\fI\->local_day_of_week\fR
.IX Subsection "$dt->local_day_of_week"
.PP
Returns the day of the week as a number, from 1..7. The day corresponding to 1
will vary based on the locale. See the \*(L"Locales\*(R" section for more details.
.PP
\fI\f(CI$dt\fI\->day_name\fR
.IX Subsection "$dt->day_name"
.PP
Returns the name of the current day of the week. See the \*(L"Locales\*(R" section
for more details.
.PP
\fI\f(CI$dt\fI\->day_abbr\fR
.IX Subsection "$dt->day_abbr"
.PP
Returns the abbreviated name of the current day of the week. See the
\&\*(L"Locales\*(R" section for more details.
.PP
\fI\f(CI$dt\fI\->day_of_year\fR
.IX Subsection "$dt->day_of_year"
.PP
Returns the day of the year.
.PP
Also available as \f(CW\*(C`$dt\->doy\*(C'\fR.
.PP
\fI\f(CI$dt\fI\->quarter\fR
.IX Subsection "$dt->quarter"
.PP
Returns the quarter of the year, from 1..4.
.PP
\fI\f(CI$dt\fI\->quarter_name\fR
.IX Subsection "$dt->quarter_name"
.PP
Returns the name of the current quarter. See the \*(L"Locales\*(R" section for more
details.
.PP
\fI\f(CI$dt\fI\->quarter_abbr\fR
.IX Subsection "$dt->quarter_abbr"
.PP
Returns the abbreviated name of the current quarter. See the \*(L"Locales\*(R"
section for more details.
.PP
\fI\f(CI$dt\fI\->day_of_quarter\fR
.IX Subsection "$dt->day_of_quarter"
.PP
Returns the day of the quarter.
.PP
Also available as \f(CW\*(C`$dt\->doq\*(C'\fR.
.PP
\fI\f(CI$dt\fI\->weekday_of_month\fR
.IX Subsection "$dt->weekday_of_month"
.PP
Returns a number from 1..5 indicating which week day of the month this is. For
example, June 9, 2003 is the second Monday of the month, and so this method
returns 2 for that date.
.PP
\fI\f(CI$dt\fI\->ymd($optional_separator), \f(CI$dt\fI\->mdy(...), \f(CI$dt\fI\->dmy(...)\fR
.IX Subsection "$dt->ymd($optional_separator), $dt->mdy(...), $dt->dmy(...)"
.PP
Each method returns the year, month, and day, in the order indicated by the
method name. Years are zero-padded to four digits. Months and days are 0\-padded
to two digits.
.PP
By default, the values are separated by a dash (\-), but this can be overridden
by passing a value to the method.
.PP
The \f(CW\*(C`$dt\->ymd\*(C'\fR method is also available as \f(CW\*(C`$dt\->date\*(C'\fR.
.PP
\fI\f(CI$dt\fI\->hour\fR
.IX Subsection "$dt->hour"
.PP
Returns the hour of the day, from 0..23.
.PP
\fI\f(CI$dt\fI\->hour_1\fR
.IX Subsection "$dt->hour_1"
.PP
Returns the hour of the day, from 1..24.
.PP
\fI\f(CI$dt\fI\->hour_12\fR
.IX Subsection "$dt->hour_12"
.PP
Returns the hour of the day, from 1..12.
.PP
\fI\f(CI$dt\fI\->hour_12_0\fR
.IX Subsection "$dt->hour_12_0"
.PP
Returns the hour of the day, from 0..11.
.PP
\fI\f(CI$dt\fI\->am_or_pm\fR
.IX Subsection "$dt->am_or_pm"
.PP
Returns the appropriate localized abbreviation, depending on the current hour.
.PP
\fI\f(CI$dt\fI\->minute\fR
.IX Subsection "$dt->minute"
.PP
Returns the minute of the hour, from 0..59.
.PP
Also available as \f(CW\*(C`$dt\->min\*(C'\fR.
.PP
\fI\f(CI$dt\fI\->second\fR
.IX Subsection "$dt->second"
.PP
Returns the second, from 0..61. The values 60 and 61 are used for leap seconds.
.PP
Also available as \f(CW\*(C`$dt\->sec\*(C'\fR.
.PP
\fI\f(CI$dt\fI\->fractional_second\fR
.IX Subsection "$dt->fractional_second"
.PP
Returns the second, as a real number from 0.0 until 61.999999999
.PP
The values 60 and 61 are used for leap seconds.
.PP
\fI\f(CI$dt\fI\->millisecond\fR
.IX Subsection "$dt->millisecond"
.PP
Returns the fractional part of the second as milliseconds (1E\-3 seconds).
.PP
Half a second is 500 milliseconds.
.PP
This value will always be rounded down to the nearest integer.
.PP
\fI\f(CI$dt\fI\->microsecond\fR
.IX Subsection "$dt->microsecond"
.PP
Returns the fractional part of the second as microseconds (1E\-6 seconds).
.PP
Half a second is 500,000 microseconds.
.PP
This value will always be rounded down to the nearest integer.
.PP
\fI\f(CI$dt\fI\->nanosecond\fR
.IX Subsection "$dt->nanosecond"
.PP
Returns the fractional part of the second as nanoseconds (1E\-9 seconds).
.PP
.Vb 1
\& Half a second is 500,000,000 nanoseconds.
.Ve
.PP
\fI\f(CI$dt\fI\->hms($optional_separator)\fR
.IX Subsection "$dt->hms($optional_separator)"
.PP
Returns the hour, minute, and second, all zero-padded to two digits. If no
separator is specified, a colon (:) is used by default.
.PP
Also available as \f(CW\*(C`$dt\->time\*(C'\fR.
.PP
\fI\f(CI$dt\fI\->datetime($optional_separator)\fR
.IX Subsection "$dt->datetime($optional_separator)"
.PP
This method is equivalent to:
.PP
.Vb 1
\&    $dt\->ymd(\*(Aq\-\*(Aq) . \*(AqT\*(Aq . $dt\->hms(\*(Aq:\*(Aq)
.Ve
.PP
The \f(CW$optional_separator\fR parameter allows you to override the separator
between the date and time, for e.g. \f(CW\*(C`$dt\->datetime(q{ })\*(C'\fR.
.PP
This method is also available as \f(CW\*(C`$dt\->iso8601\*(C'\fR, but it's not really a
very good \s-1ISO8601\s0 format, as it lacks a time zone. If called as \f(CW\*(C`$dt\->iso8601\*(C'\fR you cannot change the separator, as \s-1ISO8601\s0 specifies that \*(L"T\*(R"
must be used to separate them.
.PP
\fI\f(CI$dt\fI\->rfc3339\fR
.IX Subsection "$dt->rfc3339"
.PP
This formats a datetime in \s-1RFC3339\s0 format. This is the same as \f(CW\*(C`$dt\->datetime\*(C'\fR with an added offset at the end of the string except if the
time zone is the floating time zone.
.PP
If the offset is '+00:00' then this is represented as 'Z'. Otherwise the offset
is formatted with a leading sign (+/\-) and a colon separated numeric offset
with hours and minutes. If the offset has a non-zero seconds component, that is
also included.
.PP
\fI\f(CI$dt\fI\->stringify\fR
.IX Subsection "$dt->stringify"
.PP
This method returns a stringified version of the object. It is also how
stringification overloading is implemented. If the object has a formatter, then
its \f(CW\*(C`format_datetime\*(C'\fR method is used to produce a string. Otherwise, this
method calls \f(CW\*(C`$dt\->iso8601\*(C'\fR to produce a string. See \*(L"Formatters And
Stringification\*(R" for details.
.PP
\fI\f(CI$dt\fI\->is_leap_year\fR
.IX Subsection "$dt->is_leap_year"
.PP
This method returns a boolean value indicating whether or not the datetime
object is in a leap year.
.PP
\fI\f(CI$dt\fI\->is_last_day_of_month\fR
.IX Subsection "$dt->is_last_day_of_month"
.PP
This method returns a boolean value indicating whether or not the datetime
object is the last day of the month.
.PP
\fI\f(CI$dt\fI\->is_last_day_of_quarter\fR
.IX Subsection "$dt->is_last_day_of_quarter"
.PP
This method returns a boolean value indicating whether or not the datetime
object is the last day of the quarter.
.PP
\fI\f(CI$dt\fI\->is_last_day_of_year\fR
.IX Subsection "$dt->is_last_day_of_year"
.PP
This method returns a boolean value indicating whether or not the datetime
object is the last day of the year.
.PP
\fI\f(CI$dt\fI\->month_length\fR
.IX Subsection "$dt->month_length"
.PP
This method returns the number of days in the current month.
.PP
\fI\f(CI$dt\fI\->quarter_length\fR
.IX Subsection "$dt->quarter_length"
.PP
This method returns the number of days in the current quarter.
.PP
\fI\f(CI$dt\fI\->year_length\fR
.IX Subsection "$dt->year_length"
.PP
This method returns the number of days in the current year.
.PP
\fI\f(CI$dt\fI\->week\fR
.IX Subsection "$dt->week"
.PP
.Vb 1
\&   my ( $week_year, $week_number ) = $dt\->week;
.Ve
.PP
Returns information about the calendar week for the date. The values returned
by this method are also available separately through the \f(CW\*(C`$dt\->week_year\*(C'\fR
and \f(CW\*(C`$dt\->week_number\*(C'\fR methods.
.PP
The first week of the year is defined by \s-1ISO\s0 as the one which contains the
fourth day of January, which is equivalent to saying that it's the first week
to overlap the new year by at least four days.
.PP
Typically the week year will be the same as the year that the object is in, but
dates at the very beginning of a calendar year often end up in the last week of
the prior year, and similarly, the final few days of the year may be placed in
the first week of the next year.
.PP
\fI\f(CI$dt\fI\->week_year\fR
.IX Subsection "$dt->week_year"
.PP
Returns the year of the week. See \f(CW\*(C`$dt\->week\*(C'\fR for details.
.PP
\fI\f(CI$dt\fI\->week_number\fR
.IX Subsection "$dt->week_number"
.PP
Returns the week of the year, from 1..53. See \f(CW\*(C`$dt\->week\*(C'\fR for details.
.PP
\fI\f(CI$dt\fI\->week_of_month\fR
.IX Subsection "$dt->week_of_month"
.PP
The week of the month, from 0..5. The first week of the month is the first week
that contains a Thursday. This is based on the \s-1ICU\s0 definition of week of month,
and correlates to the \s-1ISO8601\s0 week of year definition. A day in the week
\&\fIbefore\fR the week with the first Thursday will be week 0.
.PP
\fI\f(CI$dt\fI\->jd, \f(CI$dt\fI\->mjd\fR
.IX Subsection "$dt->jd, $dt->mjd"
.PP
These return the Julian Day and Modified Julian Day, respectively. The value
returned is a floating point number. The fractional portion of the number
represents the time portion of the datetime.
.PP
The Julian Day is a count of days since the beginning of the Julian Period,
which starts with day 0 at noon on January 1, \-4712.
.PP
The Modified Julian Day is a count of days since midnight on November 17, 1858.
.PP
These methods always refer to the local time, so the Julian Day is the same for
a given datetime regardless of its time zone. Or in other words,
2020\-12\-04T13:01:57 in \*(L"America/Chicago\*(R" has the same Julian Day as
2020\-12\-04T13:01:57 in \*(L"Asia/Taipei\*(R".
.PP
\fI\f(CI$dt\fI\->time_zone\fR
.IX Subsection "$dt->time_zone"
.PP
This returns the DateTime::TimeZone object for the datetime object.
.PP
\fI\f(CI$dt\fI\->offset\fR
.IX Subsection "$dt->offset"
.PP
This returns the offset from \s-1UTC,\s0 in seconds, of the datetime object's time
zone.
.PP
\fI\f(CI$dt\fI\->is_dst\fR
.IX Subsection "$dt->is_dst"
.PP
Returns a boolean indicating whether or not the datetime's time zone is
currently in Daylight Saving Time or not.
.PP
\fI\f(CI$dt\fI\->time_zone_long_name\fR
.IX Subsection "$dt->time_zone_long_name"
.PP
This is a shortcut for \f(CW\*(C`$dt\->time_zone\->name\*(C'\fR. It's provided so that one
can use \*(L"%{time_zone_long_name}\*(R" as a strftime format specifier.
.PP
\fI\f(CI$dt\fI\->time_zone_short_name\fR
.IX Subsection "$dt->time_zone_short_name"
.PP
This method returns the time zone abbreviation for the current time zone, such
as \*(L"\s-1PST\*(R"\s0 or \*(L"\s-1GMT\*(R".\s0 These names are \fBnot\fR definitive, and should not be used in
any application intended for general use by users around the world. That's
because it's possible for multiple time zones to have the same abbreviation.
.PP
\fI\f(CI$dt\fI\->strftime( \f(CI$format\fI, ... )\fR
.IX Subsection "$dt->strftime( $format, ... )"
.PP
This method implements functionality similar to the \f(CW\*(C`strftime\*(C'\fR method in C.
However, if given multiple format strings, then it will return multiple
scalars, one for each format string.
.PP
See the \*(L"strftime Patterns\*(R" section for a list of all possible strftime
patterns.
.PP
If you give a pattern that doesn't exist, then it is simply treated as text.
.PP
Note that any deviation from the \s-1POSIX\s0 standard is probably a bug. DateTime
should match the output of \f(CW\*(C`POSIX::strftime\*(C'\fR for any given pattern.
.PP
\fI\f(CI$dt\fI\->format_cldr( \f(CI$format\fI, ... )\fR
.IX Subsection "$dt->format_cldr( $format, ... )"
.PP
This method implements formatting based on the \s-1CLDR\s0 date patterns. If given
multiple format strings, then it will return multiple scalars, one for each
format string.
.PP
See the \*(L"\s-1CLDR\s0 Patterns\*(R" section for a list of all possible \s-1CLDR\s0 patterns.
.PP
If you give a pattern that doesn't exist, then it is simply treated as text.
.PP
\fI\f(CI$dt\fI\->epoch\fR
.IX Subsection "$dt->epoch"
.PP
Returns the \s-1UTC\s0 epoch value for the datetime object. Datetimes before the start
of the epoch will be returned as a negative number.
.PP
The return value from this method is always an integer number of seconds.
.PP
Since the epoch does not account for leap seconds, the epoch time for
1972\-12\-31T23:59:60 (\s-1UTC\s0) is exactly the same as that for 1973\-01\-01T00:00:00.
.PP
\fI\f(CI$dt\fI\->hires_epoch\fR
.IX Subsection "$dt->hires_epoch"
.PP
Returns the epoch as a floating point number. The floating point portion of the
value represents the nanosecond value of the object. This method is provided
for compatibility with the \f(CW\*(C`Time::HiRes\*(C'\fR module.
.PP
Note that this method suffers from the imprecision of floating point numbers,
and the result may end up rounded to an arbitrary degree depending on your
platform.
.PP
.Vb 2
\&    my $dt = DateTime\->new( year => 2012, nanosecond => 4 );
\&    say $dt\->hires_epoch;
.Ve
.PP
On my system, this simply prints \f(CW1325376000\fR because adding \f(CW0.000000004\fR to
\&\f(CW1325376000\fR returns \f(CW1325376000\fR.
.PP
\fI\f(CI$dt\fI\->is_finite, \f(CI$dt\fI\->is_infinite\fR
.IX Subsection "$dt->is_finite, $dt->is_infinite"
.PP
These methods allow you to distinguish normal datetime objects from infinite
ones. Infinite datetime objects are documented in DateTime::Infinite.
.PP
\fI\f(CI$dt\fI\->utc_rd_values\fR
.IX Subsection "$dt->utc_rd_values"
.PP
Returns the current \s-1UTC\s0 Rata Die days, seconds, and nanoseconds as a three
element list. This exists primarily to allow other calendar modules to create
objects based on the values provided by this object.
.PP
\fI\f(CI$dt\fI\->local_rd_values\fR
.IX Subsection "$dt->local_rd_values"
.PP
Returns the current local Rata Die days, seconds, and nanoseconds as a three
element list. This exists for the benefit of other modules which might want to
use this information for date math, such as DateTime::Event::Recurrence.
.PP
\fI\f(CI$dt\fI\->leap_seconds\fR
.IX Subsection "$dt->leap_seconds"
.PP
Returns the number of leap seconds that have happened up to the datetime
represented by the object. For floating datetimes, this always returns 0.
.PP
\fI\f(CI$dt\fI\->utc_rd_as_seconds\fR
.IX Subsection "$dt->utc_rd_as_seconds"
.PP
Returns the current \s-1UTC\s0 Rata Die days and seconds purely as seconds. This
number ignores any fractional seconds stored in the object, as well as leap
seconds.
.PP
\fI\f(CI$dt\fI\->locale\fR
.IX Subsection "$dt->locale"
.PP
Returns the datetime's DateTime::Locale object.
.PP
\fI\f(CI$dt\fI\->formatter\fR
.IX Subsection "$dt->formatter"
.PP
Returns the current formatter object or class. See \*(L"Formatters And
Stringification\*(R" for details.
.ie n .SS """Set"" Methods"
.el .SS "``Set'' Methods"
.IX Subsection "Set Methods"
The remaining methods provided by \f(CW\*(C`DateTime\*(C'\fR, except where otherwise
specified, return the object itself, thus making method chaining possible. For
example:
.PP
.Vb 1
\&    my $dt = DateTime\->now\->set_time_zone( \*(AqAustralia/Sydney\*(Aq );
\&
\&    my $first = DateTime
\&                    \->last_day_of_month( year => 2003, month => 3 )
\&                    \->add( days => 1 )
\&                    \->subtract( seconds => 1 );
.Ve
.PP
\fI\f(CI$dt\fI\->set( .. )\fR
.IX Subsection "$dt->set( .. )"
.PP
This method can be used to change the local components of a date time. This
method accepts any parameter allowed by the \f(CW\*(C`new\*(C'\fR method except for \f(CW\*(C`locale\*(C'\fR
or \f(CW\*(C`time_zone\*(C'\fR. Use \f(CW\*(C`set_locale\*(C'\fR and \f(CW\*(C`set_time_zone\*(C'\fR for those instead.
.PP
This method performs parameter validation just like the \f(CW\*(C`new\*(C'\fR method.
.PP
\&\fBDo not use this method to do date math. Use the \f(CB\*(C`add\*(C'\fB and \f(CB\*(C`subtract\*(C'\fB
methods instead.\fR
.PP
\fI\f(CI$dt\fI\->set_year, \f(CI$dt\fI\->set_month, etc.\fR
.IX Subsection "$dt->set_year, $dt->set_month, etc."
.PP
DateTime has a \f(CW\*(C`set_*\*(C'\fR method for every item that can be passed to the
constructor:
.IP "\(bu" 4
\&\f(CW$dt\fR\->set_year
.IP "\(bu" 4
\&\f(CW$dt\fR\->set_month
.IP "\(bu" 4
\&\f(CW$dt\fR\->set_day
.IP "\(bu" 4
\&\f(CW$dt\fR\->set_hour
.IP "\(bu" 4
\&\f(CW$dt\fR\->set_minute
.IP "\(bu" 4
\&\f(CW$dt\fR\->set_second
.IP "\(bu" 4
\&\f(CW$dt\fR\->set_nanosecond
.PP
These are shortcuts to calling \f(CW\*(C`set\*(C'\fR with a single key. They all take a single
parameter.
.PP
\fI\f(CI$dt\fI\->truncate( to => ... )\fR
.IX Subsection "$dt->truncate( to => ... )"
.PP
This method allows you to reset some of the local time components in the object
to their \*(L"zero\*(R" values. The \f(CW\*(C`to\*(C'\fR parameter is used to specify which values to
truncate, and it may be one of \f(CW"year"\fR, \f(CW"quarter"\fR, \f(CW"month"\fR, \f(CW"week"\fR,
\&\f(CW"local_week"\fR, \f(CW"day"\fR, \f(CW"hour"\fR, \f(CW"minute"\fR, or \f(CW"second"\fR.
.PP
For example, if \f(CW"month"\fR is specified, then the local day becomes 1, and the
hour, minute, and second all become 0.
.PP
If \f(CW"week"\fR is given, then the datetime is set to the Monday of the week in
which it occurs, and the time components are all set to 0. If you truncate to
\&\f(CW"local_week"\fR, then the first day of the week is locale-dependent. For
example, in the \f(CW"en\-US"\fR locale, the first day of the week is Sunday.
.PP
\fI\f(CI$dt\fI\->set_locale($locale)\fR
.IX Subsection "$dt->set_locale($locale)"
.PP
Sets the object's locale. You can provide either a locale code like \f(CW"en\-US"\fR
or an object returned by \f(CW\*(C`DateTime::Locale\->load\*(C'\fR.
.PP
\fI\f(CI$dt\fI\->set_time_zone($tz)\fR
.IX Subsection "$dt->set_time_zone($tz)"
.PP
This method accepts either a time zone object or a string that can be passed as
the \f(CW\*(C`name\*(C'\fR parameter to \f(CW\*(C`DateTime::TimeZone\->new\*(C'\fR. If the new time zone's
offset is different from the old time zone, then the \fIlocal\fR time is adjusted
accordingly.
.PP
For example:
.PP
.Vb 8
\&    my $dt = DateTime\->new(
\&        year      => 2000,
\&        month     => 5,
\&        day       => 10,
\&        hour      => 15,
\&        minute    => 15,
\&        time_zone => \*(AqAmerica/Los_Angeles\*(Aq,
\&    );
\&
\&    print $dt\->hour;    # prints 15
\&
\&    $dt\->set_time_zone(\*(AqAmerica/Chicago\*(Aq);
\&
\&    print $dt\->hour;    # prints 17
.Ve
.PP
If the old time zone was a floating time zone, then no adjustments to the local
time are made, except to account for leap seconds. If the new time zone is
floating, then the \fI\s-1UTC\s0\fR time is adjusted in order to leave the local time
untouched.
.PP
Fans of Tsai Ming-Liang's films will be happy to know that this does work:
.PP
.Vb 2
\&    my $dt = DateTime\->now( time_zone => \*(AqAsia/Taipei\*(Aq );
\&    $dt\->set_time_zone(\*(AqEurope/Paris\*(Aq);
.Ve
.PP
Yes, now we can know \*(L"ni3 na4 bian1 ji2 dian3?\*(R"
.PP
\fI\f(CI$dt\fI\->set_formatter($formatter)\fR
.IX Subsection "$dt->set_formatter($formatter)"
.PP
Sets the formatter for the object. See \*(L"Formatters And Stringification\*(R" for
details.
.PP
You can set this to \f(CW\*(C`undef\*(C'\fR to revert to the default formatter.
.SS "Math Methods"
.IX Subsection "Math Methods"
Like the set methods, math related methods always return the object itself, to
allow for chaining:
.PP
.Vb 1
\&    $dt\->add( days => 1 )\->subtract( seconds => 1 );
.Ve
.PP
\fI\f(CI$dt\fI\->duration_class\fR
.IX Subsection "$dt->duration_class"
.PP
This returns \f(CW"DateTime::Duration"\fR, but exists so that
a subclass of \f(CW\*(C`DateTime\*(C'\fR can provide a different value.
.PP
\fI\f(CI$dt\fI\->add_duration($duration_object)\fR
.IX Subsection "$dt->add_duration($duration_object)"
.PP
This method adds a DateTime::Duration to the current datetime. See the
DateTime::Duration docs for more details.
.PP
\fI\f(CI$dt\fI\->add( parameters for DateTime::Duration )\fR
.IX Subsection "$dt->add( parameters for DateTime::Duration )"
.PP
This method is syntactic sugar around the \f(CW\*(C`$dt\->add_duration\*(C'\fR method. It
simply creates a new DateTime::Duration object using the parameters given,
and then calls the \f(CW\*(C`$dt\->add_duration\*(C'\fR method.
.PP
\fI\f(CI$dt\fI\->add($duration_object)\fR
.IX Subsection "$dt->add($duration_object)"
.PP
A synonym of \f(CW\*(C`$dt\->add_duration($duration_object)\*(C'\fR.
.PP
\fI\f(CI$dt\fI\->subtract_duration($duration_object)\fR
.IX Subsection "$dt->subtract_duration($duration_object)"
.PP
When given a DateTime::Duration object, this method simply calls \f(CW\*(C`$dur\->inverse\*(C'\fR on that object and passes that new duration to the \f(CW\*(C`$self\->add_duration\*(C'\fR method.
.PP
\fI\f(CI$dt\fI\->subtract( DateTime::Duration\->new parameters )\fR
.IX Subsection "$dt->subtract( DateTime::Duration->new parameters )"
.PP
Like \f(CW\*(C`$dt\->add\*(C'\fR, this is syntactic sugar for the \f(CW\*(C`$dt\->subtract_duration\*(C'\fR method.
.PP
\fI\f(CI$dt\fI\->subtract($duration_object)\fR
.IX Subsection "$dt->subtract($duration_object)"
.PP
A synonym of \f(CW\*(C`$dt\->subtract_duration($duration_object)\*(C'\fR.
.PP
\fI\f(CI$dt\fI\->subtract_datetime($datetime)\fR
.IX Subsection "$dt->subtract_datetime($datetime)"
.PP
This method returns a new DateTime::Duration object representing the
difference between the two dates. The duration is \fBrelative\fR to the object
from which \f(CW$datetime\fR is subtracted. For example:
.PP
.Vb 4
\&    2003\-03\-15 00:00:00.00000000
\& \-  2003\-02\-15 00:00:00.00000000
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& = 1 month
.Ve
.PP
Note that this duration is not an absolute measure of the amount of time
between the two datetimes, because the length of a month varies, as well as due
to the presence of leap seconds.
.PP
The returned duration may have deltas for months, days, minutes, seconds, and
nanoseconds.
.PP
\fI\f(CI$dt\fI\->delta_md($datetime), \f(CI$dt\fI\->delta_days($datetime)\fR
.IX Subsection "$dt->delta_md($datetime), $dt->delta_days($datetime)"
.PP
Each of these methods returns a new DateTime::Duration object representing
some portion of the difference between two datetimes.  The \f(CW\*(C`$dt\->delta_md\*(C'\fR
method returns a duration which contains only the month and day portions of the
duration is represented. The \f(CW\*(C`$dt\->delta_days\*(C'\fR method returns a duration
which contains only days.
.PP
The \f(CW\*(C`$dt\->delta_md\*(C'\fR and \f(CW\*(C`$dt\->delta_days\*(C'\fR methods truncate the
duration so that any fractional portion of a day is ignored. Both of these
methods operate on the date portion of a datetime only, and so effectively
ignore the time zone.
.PP
Unlike the subtraction methods, \fBthese methods always return a positive (or
zero) duration\fR.
.PP
\fI\f(CI$dt\fI\->delta_ms($datetime)\fR
.IX Subsection "$dt->delta_ms($datetime)"
.PP
Returns a duration which contains only minutes and seconds. Any day and month
differences are converted to minutes and seconds. This method \fBalways returns
a positive (or zero) duration\fR.
.PP
\fI\f(CI$dt\fI\->subtract_datetime_absolute($datetime)\fR
.IX Subsection "$dt->subtract_datetime_absolute($datetime)"
.PP
This method returns a new DateTime::Duration object representing the
difference between the two dates in seconds and nanoseconds. This is the only
way to accurately measure the absolute amount of time between two datetimes,
since units larger than a second do not represent a fixed number of seconds.
.PP
Note that because of leap seconds, this may not return the same result as doing
this math based on the value returned by \f(CW\*(C`$dt\->epoch\*(C'\fR.
.PP
\fI\f(CI$dt\fI\->is_between( \f(CI$lower\fI, \f(CI$upper\fI )\fR
.IX Subsection "$dt->is_between( $lower, $upper )"
.PP
Checks whether \f(CW$dt\fR is strictly between two other DateTime objects.
.PP
\&\*(L"Strictly\*(R" means that \f(CW$dt\fR must be greater than \f(CW$lower\fR and less than
\&\f(CW$upper\fR. If it is \fIequal\fR to either object then this method returns false.
.SS "Class Methods"
.IX Subsection "Class Methods"
\fIDateTime\->DefaultLocale($locale)\fR
.IX Subsection "DateTime->DefaultLocale($locale)"
.PP
This can be used to specify the default locale to be used when creating
DateTime objects. If unset, then \f(CW"en\-US"\fR is used.
.PP
This exists for backwards compatibility, but is probably best avoided. This
will change the default locale for every \f(CW\*(C`DateTime\*(C'\fR object created in your
application, even those created by third party libraries which also use
\&\f(CW\*(C`DateTime\*(C'\fR.
.PP
\fIDateTime\->compare( \f(CI$dt1\fI, \f(CI$dt2\fI ), DateTime\->compare_ignore_floating( \f(CI$dt1\fI, \f(CI$dt2\fI )\fR
.IX Subsection "DateTime->compare( $dt1, $dt2 ), DateTime->compare_ignore_floating( $dt1, $dt2 )"
.PP
.Vb 1
\&    $cmp = DateTime\->compare( $dt1, $dt2 );
\&
\&    $cmp = DateTime\->compare_ignore_floating( $dt1, $dt2 );
.Ve
.PP
This method compare two DateTime objects. The semantics are compatible with
Perl's \f(CW\*(C`sort\*(C'\fR function; it returns \f(CW\*(C`\-1\*(C'\fR if \f(CW\*(C`$dt1 < $dt2\*(C'\fR, \f(CW0\fR if \f(CW\*(C`$dt1
== $dt2\*(C'\fR, \f(CW1\fR if \f(CW\*(C`$dt1 > $dt2\*(C'\fR.
.PP
If one of the two DateTime objects has a floating time zone, it will first be
converted to the time zone of the other object. This is what you want most of
the time, but it can lead to inconsistent results when you compare a number of
DateTime objects, some of which are floating, and some of which are in other
time zones.
.PP
If you want to have consistent results (because you want to sort an array of
objects, for example), you can use the \f(CW\*(C`compare_ignore_floating\*(C'\fR method:
.PP
.Vb 1
\&    @dates = sort { DateTime\->compare_ignore_floating( $a, $b ) } @dates;
.Ve
.PP
In this case, objects with a floating time zone will be sorted as if they were
\&\s-1UTC\s0 times.
.PP
Since DateTime objects overload comparison operators, this:
.PP
.Vb 1
\&    @dates = sort @dates;
.Ve
.PP
is equivalent to this:
.PP
.Vb 1
\&    @dates = sort { DateTime\->compare( $a, $b ) } @dates;
.Ve
.PP
DateTime objects can be compared to any other calendar class that implements
the \f(CW\*(C`utc_rd_values\*(C'\fR method.
.SS "Testing Code That Uses DateTime"
.IX Subsection "Testing Code That Uses DateTime"
If you are trying to test code that calls uses DateTime, you may want to be to
explicitly set the value returned by Perl's \f(CW\*(C`time\*(C'\fR builtin. This builtin is
called by \f(CW\*(C`DateTime\->now\*(C'\fR and \f(CW\*(C`DateTime\->today\*(C'\fR.
.PP
You can override \f(CW\*(C`CORE::GLOBAL::time\*(C'\fR, but this will only work if you do this
\&\fBbefore\fR loading DateTime. If doing this is inconvenient, you can also
override \f(CW\*(C`DateTime::_core_time\*(C'\fR:
.PP
.Vb 2
\&    no warnings \*(Aqredefine\*(Aq;
\&    local *DateTime::_core_time = sub { return 42 };
.Ve
.PP
DateTime is guaranteed to call this subroutine to get the current \f(CW\*(C`time\*(C'\fR
value. You can also override the \f(CW\*(C`_core_time\*(C'\fR sub in a subclass of DateTime
and use that.
.SS "How DateTime Math Works"
.IX Subsection "How DateTime Math Works"
It's important to have some understanding of how datetime math is implemented
in order to effectively use this module and DateTime::Duration.
.PP
\fIMaking Things Simple\fR
.IX Subsection "Making Things Simple"
.PP
If you want to simplify your life and not have to think too hard about the
nitty-gritty of datetime math, I have several recommendations:
.IP "\(bu" 4
use the floating time zone
.Sp
If you do not care about time zones or leap seconds, use the \*(L"floating\*(R"
timezone:
.Sp
.Vb 1
\&    my $dt = DateTime\->now( time_zone => \*(Aqfloating\*(Aq );
.Ve
.Sp
Math done on two objects in the floating time zone produces very predictable
results.
.Sp
Note that in most cases you will want to start by creating an object in a
specific zone and \fIthen\fR convert it to the floating time zone. When an object
goes from a real zone to the floating zone, the time for the object remains the
same.
.Sp
This means that passing the floating zone to a constructor may not do what you
want.
.Sp
.Vb 1
\&    my $dt = DateTime\->now( time_zone => \*(Aqfloating\*(Aq );
.Ve
.Sp
is equivalent to
.Sp
.Vb 1
\&    my $dt = DateTime\->now( time_zone => \*(AqUTC\*(Aq )\->set_time_zone(\*(Aqfloating\*(Aq);
.Ve
.Sp
This might not be what you wanted. Instead, you may prefer to do this:
.Sp
.Vb 1
\&    my $dt = DateTime\->now( time_zone => \*(Aqlocal\*(Aq )\->set_time_zone(\*(Aqfloating\*(Aq);
.Ve
.IP "\(bu" 4
use \s-1UTC\s0 for all calculations
.Sp
If you do care about time zones (particularly \s-1DST\s0) or leap seconds, try to use
non-UTC time zones for presentation and user input only. Convert to \s-1UTC\s0
immediately and convert back to the local time zone for presentation:
.Sp
.Vb 2
\&    my $dt = DateTime\->new( %user_input, time_zone => $user_tz );
\&    $dt\->set_time_zone(\*(AqUTC\*(Aq);
\&
\&    # do various operations \- store it, retrieve it, add, subtract, etc.
\&
\&    $dt\->set_time_zone($user_tz);
\&    print $dt\->datetime;
.Ve
.IP "\(bu" 4
math on non-UTC time zones
.Sp
If you need to do date math on objects with non-UTC time zones, please read the
caveats below carefully. The results \f(CW\*(C`DateTime\*(C'\fR produces are predictable,
correct, and mostly intuitive, but datetime math gets very ugly when time zones
are involved, and there are a few strange corner cases involving subtraction of
two datetimes across a \s-1DST\s0 change.
.Sp
If you can always use the floating or \s-1UTC\s0 time zones, you can skip ahead to
\&\*(L"Leap Seconds and Date Math\*(R"
.IP "\(bu" 4
date vs datetime math
.Sp
If you only care about the date (calendar) portion of a datetime, you should
use either \f(CW\*(C`$dt\->delta_md\*(C'\fR or \f(CW\*(C`$dt\->delta_days\*(C'\fR, not \f(CW\*(C`$dt\->subtract_datetime\*(C'\fR. This will give predictable, unsurprising results,
free from DST-related complications.
.IP "\(bu" 4
\&\f(CW$dt\fR\->subtract_datetime and \f(CW$dt\fR\->add_duration
.Sp
You must convert your datetime objects to the \s-1UTC\s0 time zone before doing date
math if you want to make sure that the following formulas are always true:
.Sp
.Vb 3
\&    $dt2 \- $dt1 = $dur
\&    $dt1 + $dur = $dt2
\&    $dt2 \- $dur = $dt1
.Ve
.Sp
Note that using \f(CW\*(C`$dt\->delta_days\*(C'\fR ensures that this formula always works,
regardless of the time zones of the objects involved, as does using \f(CW\*(C`$dt\->subtract_datetime_absolute\*(C'\fR. Other methods of subtraction are not always
reversible.
.IP "\(bu" 4
never do math on two objects where only one is in the floating time zone
.Sp
The date math code accounts for leap seconds whenever the \f(CW\*(C`DateTime\*(C'\fR object is
not in the floating time zone. If you try to do math where one object is in the
floating zone and the other isn't, the results will be confusing and wrong.
.PP
\fIAdding a Duration to a DateTime\fR
.IX Subsection "Adding a Duration to a DateTime"
.PP
The parts of a duration can be broken down into five parts. These are months,
days, minutes, seconds, and nanoseconds. Adding one month to a date is
different than adding 4 weeks or 28, 29, 30, or 31 days.  Similarly, due to \s-1DST\s0
and leap seconds, adding a day can be different than adding 86,400 seconds, and
adding a minute is not exactly the same as 60 seconds.
.PP
We cannot convert between these units, except for seconds and nanoseconds,
because there is no fixed conversion between most pairs of units. That is
because of things like leap seconds, \s-1DST\s0 changes, etc.
.PP
\&\f(CW\*(C`DateTime\*(C'\fR always adds (or subtracts) days, then months, minutes, and then
seconds and nanoseconds. If there are any boundary overflows, these are
normalized at each step. For the days and months the local (not \s-1UTC\s0) values are
used. For minutes and seconds, the local values are used. This generally just
works.
.PP
This means that adding one month and one day to February 28, 2003 will produce
the date April 1, 2003, not March 29, 2003.
.PP
.Vb 1
\&    my $dt = DateTime\->new( year => 2003, month => 2, day => 28 );
\&
\&    $dt\->add( months => 1, days => 1 );
\&
\&    # 2003\-04\-01 \- the result
.Ve
.PP
On the other hand, if we add months first, and then separately add days, we end
up with March 29, 2003:
.PP
.Vb 1
\&    $dt\->add( months => 1 )\->add( days => 1 );
\&
\&    # 2003\-03\-29
.Ve
.PP
We see similar strangeness when math crosses a \s-1DST\s0 boundary:
.PP
.Vb 8
\&    my $dt = DateTime\->new(
\&        year      => 2003,
\&        month     => 4,
\&        day       => 5,
\&        hour      => 1,
\&        minute    => 58,
\&        time_zone => "America/Chicago",
\&    );
\&
\&    $dt\->add( days => 1, minutes => 3 );
\&    # 2003\-04\-06 02:01:00
\&
\&    $dt\->add( minutes => 3 )\->add( days => 1 );
\&    # 2003\-04\-06 03:01:00
.Ve
.PP
Note that if you converted the datetime object to \s-1UTC\s0 first you would get
predictable results.
.PP
If you want to know how many seconds a DateTime::Duration object represents,
you have to add it to a datetime to find out, so you could do:
.PP
.Vb 2
\&    my $now   = DateTime\->now( time_zone => \*(AqUTC\*(Aq );
\&    my $later = $now\->clone\->add_duration($duration);
\&
\&    my $seconds_dur = $later\->subtract_datetime_absolute($now);
.Ve
.PP
This returns a DateTime::Duration which only contains seconds and
nanoseconds.
.PP
If we were add the duration to a different \f(CW\*(C`DateTime\*(C'\fR object we might get a
different number of seconds.
.PP
DateTime::Duration supports three different end-of-month algorithms for
adding months. This comes into play when an addition results in a day past the
end of the following month (for example, adding one month to January 30).
.PP
.Vb 2
\&    # 2010\-08\-31 + 1 month = 2010\-10\-01
\&    $dt\->add( months => 1, end_of_month => \*(Aqwrap\*(Aq );
\&
\&    # 2010\-01\-30 + 1 month = 2010\-02\-28
\&    $dt\->add( months => 1, end_of_month => \*(Aqlimit\*(Aq );
\&
\&    # 2010\-04\-30 + 1 month = 2010\-05\-31
\&    $dt\->add( months => 1, end_of_month => \*(Aqpreserve\*(Aq );
.Ve
.PP
By default, it uses \f(CW"wrap"\fR for positive durations and \f(CW"preserve"\fR for
negative durations. See DateTime::Duration for a detailed explanation of
these algorithms.
.PP
If you need to do lots of work with durations, take a look at the
DateTime::Format::Duration module, which lets you present information from
durations in many useful ways.
.PP
There are other subtract/delta methods in \f(CW\*(C`DateTime\*(C'\fR to generate different
types of durations. These methods are \f(CW\*(C`$dt\->subtract_datetime\*(C'\fR, \f(CW\*(C`$dt\->subtract_datetime_absolute\*(C'\fR, \f(CW\*(C`$dt\->delta_md\*(C'\fR, \f(CW\*(C`$dt\->delta_days\*(C'\fR, and \f(CW\*(C`$dt\->delta_ms\*(C'\fR.
.PP
\fIDateTime Subtraction\fR
.IX Subsection "DateTime Subtraction"
.PP
Date subtraction is done based solely on the two object's local datetimes, with
one exception to handle \s-1DST\s0 changes. Also, if the two datetime objects are in
different time zones, one of them is converted to the other's time zone first
before subtraction. This is best explained through examples:
.PP
The first of these probably makes the most sense:
.PP
.Vb 7
\&    # not DST
\&    my $dt1 = DateTime\->new(
\&        year      => 2003,
\&        month     => 5,
\&        day       => 6,
\&        time_zone => \*(AqAmerica/Chicago\*(Aq,
\&    );
\&
\&    # is DST
\&    my $dt2 = DateTime\->new(
\&        year      => 2003,
\&        month     => 11,
\&        day       => 6,
\&        time_zone => \*(AqAmerica/Chicago\*(Aq,
\&    );
\&
\&    # 6 months
\&    my $dur = $dt2\->subtract_datetime($dt1);
.Ve
.PP
Nice and simple.
.PP
This one is a little trickier, but still fairly logical:
.PP
.Vb 9
\&    # is DST
\&    my $dt1 = DateTime\->new(
\&        year      => 2003,
\&        month     => 4,
\&        day       => 5,
\&        hour      => 1,
\&        minute    => 58,
\&        time_zone => "America/Chicago",
\&    );
\&
\&    # not DST
\&    my $dt2 = DateTime\->new(
\&        year      => 2003,
\&        month     => 4,
\&        day       => 7,
\&        hour      => 2,
\&        minute    => 1,
\&        time_zone => "America/Chicago",
\&    );
\&
\&    # 2 days and 3 minutes
\&    my $dur = $dt2\->subtract_datetime($dt1);
.Ve
.PP
Which contradicts the result this one gives, even though they both make sense:
.PP
.Vb 9
\&    # is DST
\&    my $dt1 = DateTime\->new(
\&        year      => 2003,
\&        month     => 4,
\&        day       => 5,
\&        hour      => 1,
\&        minute    => 58,
\&        time_zone => "America/Chicago",
\&    );
\&
\&    # not DST
\&    my $dt2 = DateTime\->new(
\&        year      => 2003,
\&        month     => 4,
\&        day       => 6,
\&        hour      => 3,
\&        minute    => 1,
\&        time_zone => "America/Chicago",
\&    );
\&
\&    # 1 day and 3 minutes
\&    my $dur = $dt2\->subtract_datetime($dt1);
.Ve
.PP
This last example illustrates the \*(L"\s-1DST\*(R"\s0 exception mentioned earlier. The
exception accounts for the fact 2003\-04\-06 only lasts 23 hours.
.PP
And finally:
.PP
.Vb 7
\&    my $dt2 = DateTime\->new(
\&        year      => 2003,
\&        month     => 10,
\&        day       => 26,
\&        hour      => 1,
\&        time_zone => \*(AqAmerica/Chicago\*(Aq,
\&    );
\&
\&    my $dt1 = $dt2\->clone\->subtract( hours => 1 );
\&
\&    # 60 minutes
\&    my $dur = $dt2\->subtract_datetime($dt1);
.Ve
.PP
This seems obvious until you realize that subtracting 60 minutes from \f(CW$dt2\fR
in the above example still leaves the clock time at \*(L"01:00:00\*(R". This time we
are accounting for a 25 hour day.
.PP
\fIReversibility\fR
.IX Subsection "Reversibility"
.PP
Date math operations are not always reversible. This is because of the way that
addition operations are ordered. As was discussed earlier, adding 1 day and 3
minutes in one call to \f(CW\*(C`$dt\->add\*(C'\fR is not the same as first adding 3
minutes and 1 day in two separate calls.
.PP
If we take a duration returned from \f(CW\*(C`$dt\->subtract_datetime\*(C'\fR and then try
to add or subtract that duration from one of the datetimes we just used, we
sometimes get interesting results:
.PP
.Vb 8
\&    my $dt1 = DateTime\->new(
\&        year      => 2003,
\&        month     => 4,
\&        day       => 5,
\&        hour      => 1,
\&        minute    => 58,
\&        time_zone => "America/Chicago",
\&    );
\&
\&    my $dt2 = DateTime\->new(
\&        year      => 2003,
\&        month     => 4,
\&        day       => 6,
\&        hour      => 3,
\&        minute    => 1,
\&        time_zone => "America/Chicago",
\&    );
\&
\&    # 1 day and 3 minutes
\&    my $dur = $dt2\->subtract_datetime($dt1);
\&
\&    # gives us $dt2
\&    $dt1\->add_duration($dur);
\&
\&    # gives us 2003\-04\-05 02:58:00 \- 1 hour later than $dt1
\&    $dt2\->subtract_duration($dur);
.Ve
.PP
The \f(CW\*(C`$dt\->subtract_duration\*(C'\fR operation gives us a (perhaps) unexpected
answer because it first subtracts one day to get 2003\-04\-05T03:01:00 and then
subtracts 3 minutes to get the final result.
.PP
If we explicitly reverse the order we can get the original value of \f(CW$dt1\fR.
This can be facilitated by the DateTime::Duration class's \f(CW\*(C`$dur\->calendar_duration\*(C'\fR and \f(CW\*(C`$dur\->clock_duration\*(C'\fR methods:
.PP
.Vb 2
\&    $dt2\->subtract_duration( $dur\->clock_duration )
\&        \->subtract_duration( $dur\->calendar_duration );
.Ve
.PP
\fILeap Seconds and Date Math\fR
.IX Subsection "Leap Seconds and Date Math"
.PP
The presence of leap seconds can cause even more anomalies in date math. For
example, the following is a legal datetime:
.PP
.Vb 9
\&    my $dt = DateTime\->new(
\&        year      => 1972,
\&        month     => 12,
\&        day       => 31,
\&        hour      => 23,
\&        minute    => 59,
\&        second    => 60,
\&        time_zone => \*(AqUTC\*(Aq
\&    );
.Ve
.PP
If we add one month ...
.PP
.Vb 1
\&    $dt\->add( months => 1 );
.Ve
.PP
\&... the datetime is now \*(L"1973\-02\-01 00:00:00\*(R", because there is no 23:59:60 on
1973\-01\-31.
.PP
Leap seconds also force us to distinguish between minutes and seconds during
date math. Given the following datetime ...
.PP
.Vb 9
\&    my $dt = DateTime\->new(
\&        year      => 1972,
\&        month     => 12,
\&        day       => 31,
\&        hour      => 23,
\&        minute    => 59,
\&        second    => 30,
\&        time_zone => \*(AqUTC\*(Aq
\&    );
.Ve
.PP
\&... we will get different results when adding 1 minute than we get if we add 60
seconds. This is because in this case, the last minute of the day, beginning at
23:59:00, actually contains 61 seconds.
.PP
Here are the results we get:
.PP
.Vb 10
\&    # 1972\-12\-31 23:59:30 \- our starting datetime
\&    my $dt = DateTime\->new(
\&        year      => 1972,
\&        month     => 12,
\&        day       => 31,
\&        hour      => 23,
\&        minute    => 59,
\&        second    => 30,
\&        time_zone => \*(AqUTC\*(Aq
\&    );
\&
\&    # 1973\-01\-01 00:00:30 \- one minute later
\&    $dt\->clone\->add( minutes => 1 );
\&
\&    # 1973\-01\-01 00:00:29 \- 60 seconds later
\&    $dt\->clone\->add( seconds => 60 );
\&
\&    # 1973\-01\-01 00:00:30 \- 61 seconds later
\&    $dt\->clone\->add( seconds => 61 );
.Ve
.PP
\fILocal vs. \s-1UTC\s0 and 24 hours vs. 1 day\fR
.IX Subsection "Local vs. UTC and 24 hours vs. 1 day"
.PP
When math crosses a daylight saving boundary, a single day may have more or
less than 24 hours.
.PP
For example, if you do this ...
.PP
.Vb 7
\&    my $dt = DateTime\->new(
\&        year      => 2003,
\&        month     => 4,
\&        day       => 5,
\&        hour      => 2,
\&        time_zone => \*(AqAmerica/Chicago\*(Aq,
\&    );
\&
\&    $dt\->add( days => 1 );
.Ve
.PP
\&... then you will produce an \fIinvalid\fR local time, and therefore an exception
will be thrown.
.PP
However, this works ...
.PP
.Vb 7
\&    my $dt = DateTime\->new(
\&        year      => 2003,
\&        month     => 4,
\&        day       => 5,
\&        hour      => 2,
\&        time_zone => \*(AqAmerica/Chicago\*(Aq,
\&    );
\&
\&    $dt\->add( hours => 24 );
.Ve
.PP
\&... and produces a datetime with the local time of \*(L"03:00\*(R".
.PP
If all this makes your head hurt, there is a simple alternative. Just convert
your datetime object to the \*(L"\s-1UTC\*(R"\s0 time zone before doing date math on it, and
switch it back to the local time zone afterwards. This avoids the possibility
of having date math throw an exception, and makes sure that 1 day equals 24
hours. Of course, this may not always be desirable, so caveat user!
.SS "Overloading"
.IX Subsection "Overloading"
This module explicitly overloads the addition (+), subtraction (\-), string and
numeric comparison operators. This means that the following all do sensible
things:
.PP
.Vb 1
\&    my $new_dt = $dt + $duration_obj;
\&
\&    my $new_dt = $dt \- $duration_obj;
\&
\&    my $duration_obj = $dt \- $new_dt;
\&
\&    for my $dt ( sort @dts ) {...}
.Ve
.PP
Additionally, the fallback parameter is set to true, so other derivable
operators (+=, \-=, etc.) will work properly. Do not expect increment (++) or
decrement (\-\-) to do anything useful.
.PP
The string comparison operators, \f(CW\*(C`eq\*(C'\fR or \f(CW\*(C`ne\*(C'\fR, will use the string value to
compare with non-DateTime objects.
.PP
DateTime objects do not have a numeric value, using \f(CW\*(C`==\*(C'\fR or \f(CW\*(C`<=>\*(C'\fR to
compare a DateTime object with a non-DateTime object will result in an
exception. To safely sort mixed DateTime and non-DateTime objects, use \f(CW\*(C`sort {
$a cmp $b } @dates\*(C'\fR.
.PP
The module also overloads stringification using the object's formatter,
defaulting to \f(CW\*(C`iso8601\*(C'\fR method. See \*(L"Formatters And Stringification\*(R" for
details.
.SS "Formatters And Stringification"
.IX Subsection "Formatters And Stringification"
You can optionally specify a \f(CW\*(C`formatter\*(C'\fR, which is usually a
\&\f(CW\*(C`DateTime::Format::*\*(C'\fR object or class, to control the stringification of the
DateTime object.
.PP
Any of the constructor methods can accept a formatter argument:
.PP
.Vb 2
\&    my $formatter = DateTime::Format::Strptime\->new(...);
\&    my $dt        = DateTime\->new( year => 2004, formatter => $formatter );
.Ve
.PP
Or, you can set it afterwards:
.PP
.Vb 2
\&    $dt\->set_formatter($formatter);
\&    $formatter = $dt\->formatter;
.Ve
.PP
Once you set the formatter, the overloaded stringification method will use the
formatter. If unspecified, the \f(CW\*(C`iso8601\*(C'\fR method is used.
.PP
A formatter can be handy when you know that in your application you want to
stringify your DateTime objects into a special format all the time, for example
in Postgres format.
.PP
If you provide a formatter class name or object, it must implement a
\&\f(CW\*(C`format_datetime\*(C'\fR method. This method will be called with just the \f(CW\*(C`DateTime\*(C'\fR
object as its argument.
.SS "\s-1CLDR\s0 Patterns"
.IX Subsection "CLDR Patterns"
The \s-1CLDR\s0 pattern language is both more powerful and more complex than strftime.
Unlike strftime patterns, you often have to explicitly escape text that you do
not want formatted, as the patterns are simply letters without any prefix.
.PP
For example, \f(CW"yyyy\-MM\-dd"\fR is a valid \s-1CLDR\s0 pattern. If you want to include
any lower or upper case \s-1ASCII\s0 characters as-is, you can surround them with
single quotes ('). If you want to include a single quote, you must escape it as
two single quotes ('').
.PP
.Vb 2
\&    my $pattern1 = q{\*(AqToday is \*(Aq EEEE};
\&    my $pattern2 = q{\*(AqIt is now\*(Aq h \*(Aqo\*(Aq\*(Aqclock\*(Aq a};
.Ve
.PP
Spaces and any non-letter text will always be passed through as-is.
.PP
Many \s-1CLDR\s0 patterns which produce numbers will pad the number with leading
zeroes depending on the length of the format specifier. For example, \f(CW"h"\fR
represents the current hour from 1\-12. If you specify \f(CW"hh"\fR then hours 1\-9
will have a leading zero prepended.
.PP
However, \s-1CLDR\s0 often uses five of a letter to represent the narrow form of a
pattern. This inconsistency is necessary for backwards compatibility.
.PP
There are many cases where \s-1CLDR\s0 patterns distinguish between the \*(L"format\*(R" and
\&\*(L"stand-alone\*(R" forms of a pattern. The format pattern is used when the thing in
question is being placed into a larger string. The stand-alone form is used
when displaying that item by itself, for example in a calendar.
.PP
There are also many cases where \s-1CLDR\s0 provides three sizes for each item, wide
(the full name), abbreviated, and narrow. The narrow form is often just a
single character, for example \*(L"T\*(R" for \*(L"Tuesday\*(R", and may not be unique.
.PP
\&\s-1CLDR\s0 provides a fairly complex system for localizing time zones that we ignore
entirely. The time zone patterns just use the information provided by
\&\f(CW\*(C`DateTime::TimeZone\*(C'\fR, and \fIdo not follow the \s-1CLDR\s0 spec\fR.
.PP
The output of a \s-1CLDR\s0 pattern is always localized, when applicable.
.PP
\&\s-1CLDR\s0 provides the following patterns:
.IP "\(bu" 4
G{1,3}
.Sp
The abbreviated era (\s-1BC, AD\s0).
.IP "\(bu" 4
\&\s-1GGGG\s0
.Sp
The wide era (Before Christ, Anno Domini).
.IP "\(bu" 4
\&\s-1GGGGG\s0
.Sp
The narrow era, if it exists (but it mostly doesn't).
.IP "\(bu" 4
y and y{3,}
.Sp
The year, zero-prefixed as needed. Negative years will start with a \*(L"\-\*(R", and
this will be included in the length calculation.
.Sp
In other, words the \*(L"yyyyy\*(R" pattern will format year \-1234 as \*(L"\-1234\*(R", not
\&\*(L"\-01234\*(R".
.IP "\(bu" 4
yy
.Sp
This is a special case. It always produces a two-digit year, so \*(L"1976\*(R" becomes
\&\*(L"76\*(R". Negative years will start with a \*(L"\-\*(R", making them one character longer.
.IP "\(bu" 4
Y{1,}
.Sp
The year in \*(L"week of the year\*(R" calendars, from \f(CW\*(C`$dt\->week_year\*(C'\fR.
.IP "\(bu" 4
u{1,}
.Sp
Same as \*(L"y\*(R" except that \*(L"uu\*(R" is not a special case.
.IP "\(bu" 4
Q{1,2}
.Sp
The quarter as a number (1..4).
.IP "\(bu" 4
\&\s-1QQQ\s0
.Sp
The abbreviated format form for the quarter.
.IP "\(bu" 4
\&\s-1QQQQ\s0
.Sp
The wide format form for the quarter.
.IP "\(bu" 4
q{1,2}
.Sp
The quarter as a number (1..4).
.IP "\(bu" 4
qqq
.Sp
The abbreviated stand-alone form for the quarter.
.IP "\(bu" 4
qqqq
.Sp
The wide stand-alone form for the quarter.
.IP "\(bu" 4
M{1,2}
.Sp
The numerical month.
.IP "\(bu" 4
\&\s-1MMM\s0
.Sp
The abbreviated format form for the month.
.IP "\(bu" 4
\&\s-1MMMM\s0
.Sp
The wide format form for the month.
.IP "\(bu" 4
\&\s-1MMMMM\s0
.Sp
The narrow format form for the month.
.IP "\(bu" 4
L{1,2}
.Sp
The numerical month.
.IP "\(bu" 4
\&\s-1LLL\s0
.Sp
The abbreviated stand-alone form for the month.
.IP "\(bu" 4
\&\s-1LLLL\s0
.Sp
The wide stand-alone form for the month.
.IP "\(bu" 4
\&\s-1LLLLL\s0
.Sp
The narrow stand-alone form for the month.
.IP "\(bu" 4
w{1,2}
.Sp
The week of the year, from \f(CW\*(C`$dt\->week_number\*(C'\fR.
.IP "\(bu" 4
W
.Sp
The week of the month, from \f(CW\*(C`$dt\->week_of_month\*(C'\fR.
.IP "\(bu" 4
d{1,2}
.Sp
The numeric day of the month.
.IP "\(bu" 4
D{1,3}
.Sp
The numeric day of the year.
.IP "\(bu" 4
F
.Sp
The day of the week in the month, from \f(CW\*(C`$dt\->weekday_of_month\*(C'\fR.
.IP "\(bu" 4
g{1,}
.Sp
The modified Julian day, from \f(CW\*(C`$dt\->mjd\*(C'\fR.
.IP "\(bu" 4
E{1,3} and eee
.Sp
The abbreviated format form for the day of the week.
.IP "\(bu" 4
\&\s-1EEEE\s0 and eeee
.Sp
The wide format form for the day of the week.
.IP "\(bu" 4
\&\s-1EEEEE\s0 and eeeee
.Sp
The narrow format form for the day of the week.
.IP "\(bu" 4
e{1,2}
.Sp
The \fIlocal\fR numeric day of the week, from 1 to 7. This number depends on what
day is considered the first day of the week, which varies by locale. For
example, in the \s-1US,\s0 Sunday is the first day of the week, so this returns 2 for
Monday.
.IP "\(bu" 4
c
.Sp
The numeric day of the week from 1 to 7, treating Monday as the first of the
week, regardless of locale.
.IP "\(bu" 4
ccc
.Sp
The abbreviated stand-alone form for the day of the week.
.IP "\(bu" 4
cccc
.Sp
The wide stand-alone form for the day of the week.
.IP "\(bu" 4
ccccc
.Sp
The narrow format form for the day of the week.
.IP "\(bu" 4
a
.Sp
The localized form of \s-1AM\s0 or \s-1PM\s0 for the time.
.IP "\(bu" 4
h{1,2}
.Sp
The hour from 1\-12.
.IP "\(bu" 4
H{1,2}
.Sp
The hour from 0\-23.
.IP "\(bu" 4
K{1,2}
.Sp
The hour from 0\-11.
.IP "\(bu" 4
k{1,2}
.Sp
The hour from 1\-24.
.IP "\(bu" 4
j{1,2}
.Sp
The hour, in 12 or 24 hour form, based on the preferred form for the locale. In
other words, this is equivalent to either \*(L"h{1,2}\*(R" or \*(L"H{1,2}\*(R".
.IP "\(bu" 4
m{1,2}
.Sp
The minute.
.IP "\(bu" 4
s{1,2}
.Sp
The second.
.IP "\(bu" 4
S{1,}
.Sp
The fractional portion of the seconds, rounded based on the length of the
specifier. This returned \fIwithout\fR a leading decimal point, but may have
leading or trailing zeroes.
.IP "\(bu" 4
A{1,}
.Sp
The millisecond of the day, based on the current time. In other words, if it is
12:00:00.00, this returns 43200000.
.IP "\(bu" 4
z{1,3}
.Sp
The time zone short name.
.IP "\(bu" 4
zzzz
.Sp
The time zone long name.
.IP "\(bu" 4
Z{1,3}
.Sp
The time zone offset.
.IP "\(bu" 4
\&\s-1ZZZZ\s0
.Sp
The time zone short name and the offset as one string, so something like
\&\*(L"\s-1CDT\-0500\*(R".\s0
.IP "\(bu" 4
\&\s-1ZZZZZ\s0
.Sp
The time zone offset as a sexagesimal number, so something like \*(L"\-05:00\*(R". (This
is useful for W3C format.)
.IP "\(bu" 4
v{1,3}
.Sp
The time zone short name.
.IP "\(bu" 4
vvvv
.Sp
The time zone long name.
.IP "\(bu" 4
V{1,3}
.Sp
The time zone short name.
.IP "\(bu" 4
\&\s-1VVVV\s0
.Sp
The time zone long name.
.PP
\fI\s-1CLDR\s0 \*(L"Available Formats\*(R"\fR
.IX Subsection "CLDR Available Formats"
.PP
The \s-1CLDR\s0 data includes pre-defined formats for various patterns such as \*(L"month
and day\*(R" or \*(L"time of day\*(R". Using these formats lets you render information
about a datetime in the most natural way for users from a given locale.
.PP
These formats are indexed by a key that is itself a \s-1CLDR\s0 pattern. When you look
these up, you get back a different \s-1CLDR\s0 pattern suitable for the locale.
.PP
Let's look at some example We'll use \f(CW\*(C`2008\-02\-05T18:30:30\*(C'\fR as our example
datetime value, and see how this is rendered for the \f(CW"en\-US"\fR and \f(CW"fr\-FR"\fR
locales.
.IP "\(bu" 4
\&\f(CW\*(C`MMMd\*(C'\fR
.Sp
The abbreviated month and day as number. For \f(CW\*(C`en\-US\*(C'\fR, we get the pattern \f(CW\*(C`MMM
d\*(C'\fR, which renders as \f(CW\*(C`Feb 5\*(C'\fR. For \f(CW\*(C`fr\-FR\*(C'\fR, we get the pattern \f(CW\*(C`d MMM\*(C'\fR, which
renders as \f(CW\*(C`5 févr.\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`yQQQ\*(C'\fR
.Sp
The year and abbreviated quarter of year. For \f(CW\*(C`en\-US\*(C'\fR, we get the pattern
\&\f(CW\*(C`QQQ y\*(C'\fR, which renders as \f(CW\*(C`Q1 2008\*(C'\fR. For \f(CW\*(C`fr\-FR\*(C'\fR, we get the same pattern,
\&\f(CW\*(C`QQQ y\*(C'\fR, which renders as \f(CW\*(C`T1 2008\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`hm\*(C'\fR
.Sp
The 12\-hour time of day without seconds. For \f(CW\*(C`en\-US\*(C'\fR, we get the pattern
\&\f(CW\*(C`h:mm a\*(C'\fR, which renders as \f(CW\*(C`6:30 PM\*(C'\fR. For \f(CW\*(C`fr\-FR\*(C'\fR, we get the exact same
pattern and rendering.
.PP
The available formats for each locale are documented in the \s-1POD\s0 for that
locale. To get back the format, you use the \f(CW\*(C`$locale\->format_for\*(C'\fR method.
For example:
.PP
.Vb 1
\&    say $dt\->format_cldr( $dt\->locale\->format_for(\*(AqMMMd\*(Aq) );
.Ve
.SS "strftime Patterns"
.IX Subsection "strftime Patterns"
The following patterns are allowed in the format string given to the \f(CW\*(C`$dt\->strftime\*(C'\fR method:
.IP "\(bu" 4
\&\f(CW%a\fR
.Sp
The abbreviated weekday name.
.IP "\(bu" 4
\&\f(CW%A\fR
.Sp
The full weekday name.
.IP "\(bu" 4
\&\f(CW%b\fR
.Sp
The abbreviated month name.
.IP "\(bu" 4
\&\f(CW%B\fR
.Sp
The full month name.
.IP "\(bu" 4
\&\f(CW%c\fR
.Sp
The default datetime format for the object's locale.
.IP "\(bu" 4
\&\f(CW%C\fR
.Sp
The century number (year/100) as a 2\-digit integer.
.IP "\(bu" 4
\&\f(CW%d\fR
.Sp
The day of the month as a decimal number (range 01 to 31).
.IP "\(bu" 4
\&\f(CW%D\fR
.Sp
Equivalent to \f(CW%m\fR/%d/%y. This is not a good standard format if you want folks
from both the United States and the rest of the world to understand the date!
.IP "\(bu" 4
\&\f(CW%e\fR
.Sp
Like \f(CW%d\fR, the day of the month as a decimal number, but a leading zero is
replaced by a space.
.IP "\(bu" 4
\&\f(CW%F\fR
.Sp
Equivalent to \f(CW%Y\fR\-%m\-%d (the \s-1ISO 8601\s0 date format)
.IP "\(bu" 4
\&\f(CW%G\fR
.Sp
The \s-1ISO 8601\s0 year with century as a decimal number. The 4\-digit year
corresponding to the \s-1ISO\s0 week number (see \f(CW%V\fR). This has the same format and
value as \f(CW%Y\fR, except that if the \s-1ISO\s0 week number belongs to the previous or next
year, that year is used instead. (\s-1TZ\s0)
.IP "\(bu" 4
\&\f(CW%g\fR
.Sp
Like \f(CW%G\fR, but without century, i.e., with a 2\-digit year (00\-99).
.IP "\(bu" 4
\&\f(CW%h\fR
.Sp
Equivalent to \f(CW%b\fR.
.IP "\(bu" 4
\&\f(CW%H\fR
.Sp
The hour as a decimal number using a 24\-hour clock (range 00 to 23).
.IP "\(bu" 4
\&\f(CW%I\fR
.Sp
The hour as a decimal number using a 12\-hour clock (range 01 to 12).
.IP "\(bu" 4
\&\f(CW%j\fR
.Sp
The day of the year as a decimal number (range 001 to 366).
.IP "\(bu" 4
\&\f(CW%k\fR
.Sp
The hour (24\-hour clock) as a decimal number (range 0 to 23); single digits are
preceded by a blank. (See also \f(CW%H\fR.)
.IP "\(bu" 4
\&\f(CW%l\fR
.Sp
The hour (12\-hour clock) as a decimal number (range 1 to 12); single digits are
preceded by a blank. (See also \f(CW%I\fR.)
.IP "\(bu" 4
\&\f(CW%m\fR
.Sp
The month as a decimal number (range 01 to 12).
.IP "\(bu" 4
\&\f(CW%M\fR
.Sp
The minute as a decimal number (range 00 to 59).
.IP "\(bu" 4
\&\f(CW%n\fR
.Sp
A newline character.
.IP "\(bu" 4
\&\f(CW%N\fR
.Sp
The fractional seconds digits. Default is 9 digits (nanoseconds).
.Sp
.Vb 3
\&    %3N   milliseconds (3 digits)
\&    %6N   microseconds (6 digits)
\&    %9N   nanoseconds  (9 digits)
.Ve
.Sp
This value will always be rounded down to the nearest integer.
.IP "\(bu" 4
\&\f(CW%p\fR
.Sp
Either `\s-1AM\s0' or `\s-1PM\s0' according to the given time value, or the corresponding
strings for the current locale. Noon is treated as `pm' and midnight as `am'.
.IP "\(bu" 4
\&\f(CW%P\fR
.Sp
Like \f(CW%p\fR but in lowercase: `am' or `pm' or a corresponding string for the
current locale.
.IP "\(bu" 4
\&\f(CW%r\fR
.Sp
The time in a.m. or p.m. notation. In the \s-1POSIX\s0 locale this is equivalent to
`%I:%M:%S \f(CW%p\fR'.
.IP "\(bu" 4
\&\f(CW%R\fR
.Sp
The time in 24\-hour notation (%H:%M). (\s-1SU\s0) For a version including the seconds,
see \f(CW%T\fR below.
.IP "\(bu" 4
\&\f(CW%s\fR
.Sp
The number of seconds since the epoch.
.IP "\(bu" 4
\&\f(CW%S\fR
.Sp
The second as a decimal number (range 00 to 61).
.IP "\(bu" 4
\&\f(CW%t\fR
.Sp
A tab character.
.IP "\(bu" 4
\&\f(CW%T\fR
.Sp
The time in 24\-hour notation (%H:%M:%S).
.IP "\(bu" 4
\&\f(CW%u\fR
.Sp
The day of the week as a decimal, range 1 to 7, Monday being 1. See also \f(CW%w\fR.
.IP "\(bu" 4
\&\f(CW%U\fR
.Sp
The week number of the current year as a decimal number, range 00 to 53,
starting with the first Sunday as the first day of week 01. See also \f(CW%V\fR and \f(CW%W\fR.
.IP "\(bu" 4
\&\f(CW%V\fR
.Sp
The \s-1ISO 8601:1988\s0 week number of the current year as a decimal number, range 01
to 53, where week 1 is the first week that has at least 4 days in the current
year, and with Monday as the first day of the week. See also \f(CW%U\fR and \f(CW%W\fR.
.IP "\(bu" 4
\&\f(CW%w\fR
.Sp
The day of the week as a decimal, range 0 to 6, Sunday being 0. See also \f(CW%u\fR.
.IP "\(bu" 4
\&\f(CW%W\fR
.Sp
The week number of the current year as a decimal number, range 00 to 53,
starting with the first Monday as the first day of week 01.
.IP "\(bu" 4
\&\f(CW%x\fR
.Sp
The default date format for the object's locale.
.IP "\(bu" 4
\&\f(CW%X\fR
.Sp
The default time format for the object's locale.
.IP "\(bu" 4
\&\f(CW%y\fR
.Sp
The year as a decimal number without a century (range 00 to 99).
.IP "\(bu" 4
\&\f(CW%Y\fR
.Sp
The year as a decimal number including the century.
.IP "\(bu" 4
\&\f(CW%z\fR
.Sp
The time-zone as hour offset from \s-1UTC.\s0 Required to emit RFC822\-conformant dates
(using \*(L"%a, \f(CW%d\fR \f(CW%b\fR \f(CW%Y\fR \f(CW%H:\fR%M:%S \f(CW%z\fR\*(R").
.IP "\(bu" 4
\&\f(CW%Z\fR
.Sp
The short name for the time zone, typically an abbreviation like \*(L"\s-1EST\*(R"\s0 or
\&\*(L"\s-1AEST\*(R".\s0
.IP "\(bu" 4
%%
.Sp
A literal `%' character.
.IP "\(bu" 4
%{method}
.Sp
Any method name may be specified using the format \f(CW\*(C`%{method}\*(C'\fR name where
\&\*(L"method\*(R" is a valid \f(CW\*(C`DateTime\*(C'\fR object method.
.SS "DateTime and Storable"
.IX Subsection "DateTime and Storable"
\&\f(CW\*(C`DateTime\*(C'\fR implements Storable hooks in order to reduce the size of a
serialized \f(CW\*(C`DateTime\*(C'\fR object.
.SH "DEVELOPMENT TOOLS"
.IX Header "DEVELOPMENT TOOLS"
If you're working on the \f(CW\*(C`DateTIme\*(C'\fR code base, there are a few extra non-Perl
tools that you may find useful, notably
precious <https://github.com/houseabsolute/precious>, a meta\-linter/tidier.
You can install all the necessary tools in \f(CW\*(C`$HOME/bin\*(C'\fR by running
\&\fI./dev\-bin/install\-dev\-tools.sh\fR.
.PP
Try running \f(CW\*(C`precious tidy \-a\*(C'\fR to tidy all the tidyable files in the repo, and
\&\f(CW\*(C`precious lint \-a\*(C'\fR to run all the lint checks.
.PP
You can enable a git pre-commit hook for linting by running \fI./git/setup.pl\fR.
.PP
Note that linting will be checked in \s-1CI,\s0 and it's okay to submit a \s-1PR\s0 which
fails the linting check, but it's extra nice to fix these yourself.
.SH "THE DATETIME PROJECT ECOSYSTEM"
.IX Header "THE DATETIME PROJECT ECOSYSTEM"
This module is part of a larger ecosystem of modules in the DateTime family.
.SS "DateTime::Set"
.IX Subsection "DateTime::Set"
The DateTime::Set module represents sets (including recurrences) of
datetimes. Many modules return sets or recurrences.
.SS "Format Modules"
.IX Subsection "Format Modules"
The various format modules exist to parse and format datetimes. For example,
DateTime::Format::HTTP parses dates according to the \s-1RFC 1123\s0 format:
.PP
.Vb 3
\&    my $datetime
\&        = DateTime::Format::HTTP\->parse_datetime(
\&        \*(AqThu Feb  3 17:03:55 GMT 1994\*(Aq);
\&
\&    print DateTime::Format::HTTP\->format_datetime($datetime);
.Ve
.PP
Most format modules are suitable for use as a \f(CW\*(C`formatter\*(C'\fR with a DateTime
object.
.PP
All format modules start with
DateTime::Format:: <https://metacpan.org/search?q=datetime%3A%3Aformat>.
.SS "Calendar Modules"
.IX Subsection "Calendar Modules"
There are a number of modules on \s-1CPAN\s0 that implement non-Gregorian calendars,
such as the Chinese, Mayan, and Julian calendars.
.PP
All calendar modules start with
DateTime::Calendar:: <https://metacpan.org/search?q=datetime%3A%3Acalendar>.
.SS "Event Modules"
.IX Subsection "Event Modules"
There are a number of modules that calculate the dates for events, such as
Easter, Sunrise, etc.
.PP
All event modules start with
DateTime::Event:: <https://metacpan.org/search?q=datetime%3A%3Aevent>.
.SS "Others"
.IX Subsection "Others"
There are many other modules that work with DateTime, including modules in the
DateTimeX namespace <https://metacpan.org/search?q=datetimex> namespace, as
well as others.
.PP
See MetaCPAN <https://metacpan.org/search?q=datetime> for more modules.
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
The tests in \fI20infinite.t\fR seem to fail on some machines, particularly on
Win32. This appears to be related to Perl's internal handling of \s-1IEEE\s0 infinity
and NaN, and seems to be highly platform/compiler/phase of moon dependent.
.PP
If you don't plan to use infinite datetimes you can probably ignore this. This
will be fixed (perhaps) in future versions.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
A Date with
Perl <http://presentations.houseabsolute.com/a-date-with-perl/> \- a talk
I've given at a few YAPCs.
.PP
datetime@perl.org mailing list <http://lists.perl.org/list/datetime.html>
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs may be submitted at <https://github.com/houseabsolute/DateTime.pm/issues>.
.PP
There is a mailing list available for users of this distribution,
<mailto:datetime@perl.org>.
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for DateTime can be found at <https://github.com/houseabsolute/DateTime.pm>.
.SH "DONATIONS"
.IX Header "DONATIONS"
If you'd like to thank me for the work I've done on this module, please
consider making a \*(L"donation\*(R" to me via PayPal. I spend a lot of free time
creating free software, and would appreciate any support you'd care to offer.
.PP
Please note that \fBI am not suggesting that you must do this\fR in order for me
to continue working on this particular software. I will continue to do so,
inasmuch as I have in the past, for as long as it interests me.
.PP
Similarly, a donation made in this way will probably not make me work on this
software much more, unless I get so many donations that I can consider working
on free software full time (let's all have a chuckle at that together).
.PP
To donate, log into PayPal and send money to autarch@urth.org, or use the
button at <https://www.urth.org/fs\-donation.html>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dave Rolsky <autarch@urth.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Ben Bennett <fiji@limey.net>
.IP "\(bu" 4
Christian Hansen <chansen@cpan.org>
.IP "\(bu" 4
Daisuke Maki <dmaki@cpan.org>
.IP "\(bu" 4
Dan Book <grinnz@gmail.com>
.IP "\(bu" 4
Dan Stewart <danielandrewstewart@gmail.com>
.IP "\(bu" 4
David Dyck <david.dyck@checksum.com>
.IP "\(bu" 4
David E. Wheeler <david@justatheory.com>
.IP "\(bu" 4
David Precious <davidp@preshweb.co.uk>
.IP "\(bu" 4
Doug Bell <madcityzen@gmail.com>
.IP "\(bu" 4
Flávio Soibelmann Glock <fglock@gmail.com>
.IP "\(bu" 4
Gianni Ceccarelli <gianni.ceccarelli@broadbean.com>
.IP "\(bu" 4
Gregory Oschwald <oschwald@gmail.com>
.IP "\(bu" 4
Hauke D <haukex@zero\-g.net>
.IP "\(bu" 4
Iain Truskett <deceased>
.IP "\(bu" 4
Jason McIntosh <jmac@jmac.org>
.IP "\(bu" 4
Joshua Hoblitt <jhoblitt@cpan.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Mark Overmeer <mark@overmeer.net>
.IP "\(bu" 4
Michael Conrad <mike@nrdvana.net>
.IP "\(bu" 4
Michael R. Davis <mrdvt92@users.noreply.github.com>
.IP "\(bu" 4
Mohammad S Anwar <mohammad.anwar@yahoo.com>
.IP "\(bu" 4
M Somerville <dracos@users.noreply.github.com>
.IP "\(bu" 4
Nick Tonkin <1nickt@users.noreply.github.com>
.IP "\(bu" 4
Olaf Alders <olaf@wundersolutions.com>
.IP "\(bu" 4
Ovid <curtis_ovid_poe@yahoo.com>
.IP "\(bu" 4
Paul Howarth <paul@city\-fan.org>
.IP "\(bu" 4
Philippe Bruhat (BooK) <book@cpan.org>
.IP "\(bu" 4
philip r brenan <philiprbrenan@gmail.com>
.IP "\(bu" 4
Ricardo Signes <rjbs@cpan.org>
.IP "\(bu" 4
Richard Bowen <bowen@cpan.org>
.IP "\(bu" 4
Ron Hill <rkhill@cpan.org>
.IP "\(bu" 4
Sam Kington <github@illuminated.co.uk>
.IP "\(bu" 4
viviparous <viviparous@prc>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2003 \- 2022 by Dave Rolsky.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
.PP
The full text of the license can be found in the
\&\fI\s-1LICENSE\s0\fR file included with this distribution.
