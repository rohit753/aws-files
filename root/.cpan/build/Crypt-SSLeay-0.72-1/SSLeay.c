/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.40 from the
 * contents of SSLeay.xs. Do not edit this file, edit SSLeay.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "SSLeay.xs"
/*
 * $Id: SSLeay.xs,v 1.2 2000/05/10 16:37:25 ben Exp $
 * Copyright 1998 Gisle Aas.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the same terms as Perl itself.
 */

#ifdef __cplusplus
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"

/* CRYPT_SSLEAY_free() will not be #defined to be free() now that we're no
 * longer supporting pre-2000 OpenSSL.
#define NO_XSLOCKS
*/

#include "XSUB.h"

/* build problem under openssl 0.9.6 and some builds of perl 5.8.x */
#ifndef PERL5
#define PERL5 1
#endif

/* Makefile.PL no longer generates the following header file
 * #include "crypt_ssleay_version.h"
 * Among other things, Makefile.PL used to determine whether
 * to use #include<openssl/ssl.h> or #include<ssl.h> and
 * whether to use OPENSSL_free or free etc, but such distinctions
 * ceased to matter pre-2000. Crypt::SSLeay no longer supports
 * pre-2000 OpenSSL */

#include <openssl/ssl.h>
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/rand.h>
#include <openssl/pkcs12.h>

#define CRYPT_SSLEAY_free OPENSSL_free

#undef Free /* undo namespace pollution from crypto.h */
#ifdef __cplusplus
}
#endif


#if SSLEAY_VERSION_NUMBER >= 0x0900
#define CRYPT_SSL_CLIENT_METHOD SSLv3_client_method()
#else
#define CRYPT_SSL_CLIENT_METHOD SSLv2_client_method()
#endif

static void InfoCallback(const SSL *s,int where,int ret)
    {
    const char *str;
    int w;

    w = where & ~SSL_ST_MASK;

    if(w & SSL_ST_CONNECT)
       str="SSL_connect";
    else if(w & SSL_ST_ACCEPT)
       str="SSL_accept";
    else
       str="undefined";

    if(where & SSL_CB_LOOP) {
       fprintf(stderr,"%s:%s\n",str,SSL_state_string_long(s));
    }
    else if(where & SSL_CB_ALERT) {
       str=(where & SSL_CB_READ)?"read":"write";
       fprintf(stderr,"SSL3 alert %s:%s:%s\n",str,
           SSL_alert_type_string_long(ret),
           SSL_alert_desc_string_long(ret));
       }
    else if(where & SSL_CB_EXIT) {
       if(ret == 0)
         fprintf(stderr,"%s:failed in %s\n",str,SSL_state_string_long(s));
       else if (ret < 0)
         fprintf(stderr,"%s:error in %s\n",str,SSL_state_string_long(s));
       }
    }

#line 96 "SSLeay.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 240 "SSLeay.c"
#define CRYPT_SSLEAY_ERR_BUFSIZE 1024

XS_EUPXS(XS_Crypt__SSLeay__Err_get_error_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Err_get_error_string)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 97 "SSLeay.xs"
        unsigned long code;
        char buf[ CRYPT_SSLEAY_ERR_BUFSIZE ];

#line 254 "SSLeay.c"
	const char *	RETVAL;
	dXSTARG;
#line 101 "SSLeay.xs"
        if ((code = ERR_get_error()) == 0) {
            RETVAL = NULL;
        }
        else {
            /* www.openssl.org/docs/crypto/ERR_error_string.html */
            ERR_error_string_n(code, buf, CRYPT_SSLEAY_ERR_BUFSIZE);
            RETVAL = buf;
        }
#line 266 "SSLeay.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#define CRYPT_SSLEAY_RAND_BUFSIZE 1024

XS_EUPXS(XS_Crypt__SSLeay__CTX_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__CTX_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, ssl_version");
    {
	SV*	packname = ST(0)
;
	int	ssl_version = (int)SvIV(ST(1))
;
	SSL_CTX *	RETVAL;
#line 121 "SSLeay.xs"
        SSL_CTX* ctx;
        static int bNotFirstTime;
        char buf[ CRYPT_SSLEAY_RAND_BUFSIZE ];

        if(!bNotFirstTime) {
            OpenSSL_add_all_algorithms();
            SSL_load_error_strings();
            ERR_load_crypto_strings();
            SSL_library_init();
            bNotFirstTime = 1;
        }

        /**** Code from Devin Heitmueller, 10/3/2002 ****/
        /**** Use /dev/urandom to seed if available  ****/
        /* ASU: 2014/04/23 It looks like it is OK to leave
         * this in. See following thread:
         * http://security.stackexchange.com/questions/56469/
         */
       if (RAND_load_file("/dev/urandom", CRYPT_SSLEAY_RAND_BUFSIZE)
            != CRYPT_SSLEAY_RAND_BUFSIZE)
        {
            /* Couldn't read /dev/urandom, just seed off
             * of the stack variable (the old way)
             */
            RAND_seed(buf, CRYPT_SSLEAY_RAND_BUFSIZE);
        }

        if(ssl_version == 23) {
            ctx = SSL_CTX_new(SSLv23_client_method());
        }
        else if(ssl_version == 3) {
            ctx = SSL_CTX_new(SSLv3_client_method());
        }
        else {
#ifndef OPENSSL_NO_SSL2
            /* v2 is the default */
            ctx = SSL_CTX_new(SSLv2_client_method());
#else
            /* v3 is the default */
            ctx = SSL_CTX_new(SSLv3_client_method());
#endif
        }

        SSL_CTX_set_options(ctx,SSL_OP_ALL|0);
        SSL_CTX_set_default_verify_paths(ctx);
        SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);
        RETVAL = ctx;
#line 334 "SSLeay.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Crypt::SSLeay::CTX", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__CTX_free); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__CTX_free)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX*	ctx;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::CTX")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ctx = INT2PTR(SSL_CTX *, stack_top);
        }
        else
            croak("ctx is not an Crypt::SSLeay::CTX")
;

	SSL_CTX_free(ctx);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Crypt__SSLeay__CTX_set_cipher_list); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__CTX_set_cipher_list)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "ctx, ciphers");
    {
	SSL_CTX*	ctx;
	char*	ciphers = (char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::CTX")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ctx = INT2PTR(SSL_CTX *, stack_top);
        }
        else
            croak("ctx is not an Crypt::SSLeay::CTX")
;

	RETVAL = SSL_CTX_set_cipher_list(ctx, ciphers);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__CTX_use_certificate_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__CTX_use_certificate_file)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "ctx, filename, mode");
    {
	SSL_CTX*	ctx;
	char*	filename = (char *)SvPV_nolen(ST(1))
;
	int	mode = (int)SvIV(ST(2))
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::CTX")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ctx = INT2PTR(SSL_CTX *, stack_top);
        }
        else
            croak("ctx is not an Crypt::SSLeay::CTX")
;

	RETVAL = SSL_CTX_use_certificate_file(ctx, filename, mode);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__CTX_use_PrivateKey_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__CTX_use_PrivateKey_file)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "ctx, filename, mode");
    {
	SSL_CTX*	ctx;
	char*	filename = (char *)SvPV_nolen(ST(1))
;
	int	mode = (int)SvIV(ST(2))
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::CTX")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ctx = INT2PTR(SSL_CTX *, stack_top);
        }
        else
            croak("ctx is not an Crypt::SSLeay::CTX")
;

	RETVAL = SSL_CTX_use_PrivateKey_file(ctx, filename, mode);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__CTX_use_pkcs12_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__CTX_use_pkcs12_file)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "ctx, filename, password");
    {
	SSL_CTX*	ctx;
	const char *	filename = (const char *)SvPV_nolen(ST(1))
;
	const char *	password = (const char *)SvPV_nolen(ST(2))
;
#line 198 "SSLeay.xs"
        FILE *fp;
        EVP_PKEY *pkey;
        X509 *cert;
        STACK_OF(X509) *ca = NULL;
        PKCS12 *p12;
#line 475 "SSLeay.c"
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::CTX")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ctx = INT2PTR(SSL_CTX *, stack_top);
        }
        else
            croak("ctx is not an Crypt::SSLeay::CTX")
;
#line 204 "SSLeay.xs"
        if ((fp = fopen(filename, "rb"))) {
            p12 = d2i_PKCS12_fp(fp, NULL);
            fclose (fp);

            if (p12) {
                if(PKCS12_parse(p12, password, &pkey, &cert, &ca)) {
                    if (pkey) {
                        RETVAL = SSL_CTX_use_PrivateKey(ctx, pkey);
                        EVP_PKEY_free(pkey);
                    }
                    if (cert) {
                        RETVAL = SSL_CTX_use_certificate(ctx, cert);
                        X509_free(cert);
                    }
                }
                PKCS12_free(p12);
            }
        }
#line 505 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__CTX_check_private_key); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__CTX_check_private_key)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX*	ctx;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::CTX")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ctx = INT2PTR(SSL_CTX *, stack_top);
        }
        else
            croak("ctx is not an Crypt::SSLeay::CTX")
;

	RETVAL = SSL_CTX_check_private_key(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__CTX_set_verify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__CTX_set_verify)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	SSL_CTX*	ctx;
#line 234 "SSLeay.xs"
        char* CAfile;
        char* CAdir;
#line 549 "SSLeay.c"
	SV *	RETVAL;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::CTX")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ctx = INT2PTR(SSL_CTX *, stack_top);
        }
        else
            croak("ctx is not an Crypt::SSLeay::CTX")
;
#line 237 "SSLeay.xs"
        CAfile=getenv("HTTPS_CA_FILE");
        CAdir =getenv("HTTPS_CA_DIR");

        if(!CAfile && !CAdir) {
            SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);
            RETVAL = newSViv(0);
        }
        else {
            SSL_CTX_load_verify_locations(ctx,CAfile,CAdir);
            SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, NULL);
            RETVAL = newSViv(1);
        }
#line 572 "SSLeay.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Conn_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Conn_new)
{
    dVAR; dXSARGS;
    if (items < 3)
       croak_xs_usage(cv,  "packname, ctx, debug, ...");
    {
	SV*	packname = ST(0)
;
	SSL_CTX*	ctx;
	SV*	debug = ST(2)
;
#line 260 "SSLeay.xs"
        SSL* ssl;
#line 594 "SSLeay.c"
	SSL *	RETVAL;

        if (sv_derived_from(ST(1), "Crypt::SSLeay::CTX")) {
            IV stack_top = SvIV((SV*)SvRV(ST(1)));
            ctx = INT2PTR(SSL_CTX *, stack_top);
        }
        else
            croak("ctx is not an Crypt::SSLeay::CTX")
;
#line 262 "SSLeay.xs"
           ssl = SSL_new(ctx);
           SSL_set_connect_state(ssl);
           /* The set mode is necessary so the SSL connection can
            * survive a renegotiated cipher that results from
            * modssl VerifyClient config changing between
            * VirtualHost & some other config block.  At modssl
            * this would be a [trace] ssl message:
            *  "Changed client verification type will force renegotiation"
            * -- jc 6/28/2001
            */
#ifdef SSL_MODE_AUTO_RETRY
           SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);
#endif
           RETVAL = ssl;
           if(SvTRUE(debug)) {
             SSL_set_info_callback(RETVAL,InfoCallback);
           }
           if (items > 2) {
               PerlIO* io = IoIFP(sv_2io(ST(3)));
#ifdef _WIN32
               SSL_set_fd(RETVAL, _get_osfhandle(PerlIO_fileno(io)));
#else
               SSL_set_fd(RETVAL, PerlIO_fileno(io));
#endif
           }
#line 630 "SSLeay.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Crypt::SSLeay::Conn", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Conn_free); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Conn_free)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL*	ssl;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::Conn")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ssl = INT2PTR(SSL *, stack_top);
        }
        else
            croak("ssl is not an Crypt::SSLeay::Conn")
;

	SSL_free(ssl);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Crypt__SSLeay__Conn_pending); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Conn_pending)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL*	ssl;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::Conn")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ssl = INT2PTR(SSL *, stack_top);
        }
        else
            croak("ssl is not an Crypt::SSLeay::Conn")
;

	RETVAL = SSL_pending(ssl);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Conn_set_fd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Conn_set_fd)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "ssl, fd");
    {
	SSL*	ssl;
	int	fd = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::Conn")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ssl = INT2PTR(SSL *, stack_top);
        }
        else
            croak("ssl is not an Crypt::SSLeay::Conn")
;

	RETVAL = SSL_set_fd(ssl, fd);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Conn_connect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Conn_connect)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL*	ssl;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::Conn")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ssl = INT2PTR(SSL *, stack_top);
        }
        else
            croak("ssl is not an Crypt::SSLeay::Conn")
;

	RETVAL = SSL_connect(ssl);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Conn_accept); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Conn_accept)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL*	ssl;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::Conn")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ssl = INT2PTR(SSL *, stack_top);
        }
        else
            croak("ssl is not an Crypt::SSLeay::Conn")
;

	RETVAL = SSL_accept(ssl);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Conn_write); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Conn_write)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "ssl, buf, ...");
    {
	SSL*	ssl;
#line 315 "SSLeay.xs"
           STRLEN blen;
           int len;
           int offset = 0;
           int keep_trying_to_write = 1;
#line 784 "SSLeay.c"
	char*	buf = SvPV(ST(1), blen);
	SV *	RETVAL;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::Conn")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ssl = INT2PTR(SSL *, stack_top);
        }
        else
            croak("ssl is not an Crypt::SSLeay::Conn")
;
#line 322 "SSLeay.xs"
           if (items > 2) {
               len = SvOK(ST(2)) ? SvIV(ST(2)) : blen;
               if (items > 3) {
                   offset = SvIV(ST(3));
                   if (offset < 0) {
                       if (-offset > blen)
                           croak("Offset outside string");
                       offset += blen;
                   }
                   else if (offset >= blen && blen > 0)
                       croak("Offset outside string");
               }
               if (len > blen - offset)
                   len = blen - offset;
           }
           else {
               len = blen;
           }

           /* try to handle incomplete writes properly
            * see RT bug #64054 and RT bug #78695
            * 2012/08/02: Stop trying to distinguish between good & bad
            * zero returns from underlying SSL_read/SSL_write
            */
           while (keep_trying_to_write)
           {
                int n = SSL_write(ssl, buf+offset, len);
                int x = SSL_get_error(ssl, n);

                if ( n >= 0 )
                {
                    keep_trying_to_write = 0;
                    RETVAL = newSViv(n);
                }
                else
                {
                    if
                    (
                        (x != SSL_ERROR_WANT_READ) &&
                        (x != SSL_ERROR_WANT_WRITE)
                    )
                    {
                        keep_trying_to_write = 0;
                        RETVAL = &PL_sv_undef;
                    }
                }
           }
#line 843 "SSLeay.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Conn_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Conn_read)
{
    dVAR; dXSARGS;
    if (items < 3)
       croak_xs_usage(cv,  "ssl, buf, len, ...");
    {
	SSL*	ssl;
	int	len = (int)SvIV(ST(2))
;
#line 377 "SSLeay.xs"
           char *buf;
           STRLEN blen;
           int offset = 0;
           int keep_trying_to_read = 1;
#line 866 "SSLeay.c"
	SV*	sv = ST(1);
	SV *	RETVAL;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::Conn")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ssl = INT2PTR(SSL *, stack_top);
        }
        else
            croak("ssl is not an Crypt::SSLeay::Conn")
;
#line 384 "SSLeay.xs"
           buf = SvPV_force(sv, blen);
           if (items > 3) {
               offset = SvIV(ST(3));
               if (offset < 0) {
                   if (-offset > blen)
                       croak("Offset outside string");
                   offset += blen;
               }
               /* this is not a very efficient method of appending
                * (offset - blen) NUL bytes, but it will probably
                * seldom happen.
                */
               while (offset > blen) {
                   sv_catpvn(sv, "\0", 1);
                   blen++;
               }
           }
           if (len < 0)
               croak("Negative length");

           SvGROW(sv, offset + len + 1);
           buf = SvPVX(sv);  /* it might have been relocated */

           /* try to handle incomplete writes properly
            * see RT bug #64054 and RT bug #78695
            * 2012/08/02: Stop trying to distinguish between good & bad
            * zero returns from underlying SSL_read/SSL_write
            */
           while (keep_trying_to_read) {
                int n = SSL_read(ssl, buf+offset, len);
                int x = SSL_get_error(ssl, n);

                if ( n >= 0 )
                {
                    SvCUR_set(sv, offset + n);
                    buf[offset + n] = '\0';
                    keep_trying_to_read = 0;
                    RETVAL = newSViv(n);
                }
                else
                {
                    if
                    (
                        (x != SSL_ERROR_WANT_READ) &&
                        (x != SSL_ERROR_WANT_WRITE)
                    )
                    {
                        keep_trying_to_read = 0;
                        RETVAL = &PL_sv_undef;
                    }
                }
           }
#line 930 "SSLeay.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Conn_get_peer_certificate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Conn_get_peer_certificate)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL*	ssl;
	X509 *	RETVAL;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::Conn")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ssl = INT2PTR(SSL *, stack_top);
        }
        else
            croak("ssl is not an Crypt::SSLeay::Conn")
;

	RETVAL = SSL_get_peer_certificate(ssl);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Crypt::SSLeay::X509", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Conn_get_verify_result); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Conn_get_verify_result)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL*	ssl;
	SV *	RETVAL;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::Conn")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ssl = INT2PTR(SSL *, stack_top);
        }
        else
            croak("ssl is not an Crypt::SSLeay::Conn")
;
#line 447 "SSLeay.xs"
           RETVAL = newSViv((SSL_get_verify_result(ssl) == X509_V_OK) ? 1 : 0);
#line 987 "SSLeay.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}

#define CRYPT_SSLEAY_SHARED_CIPHERS_BUFSIZE 512

XS_EUPXS(XS_Crypt__SSLeay__Conn_get_shared_ciphers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Conn_get_shared_ciphers)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL*	ssl;
#line 457 "SSLeay.xs"
        char buf[ CRYPT_SSLEAY_SHARED_CIPHERS_BUFSIZE ];
#line 1006 "SSLeay.c"
	char *	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::Conn")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ssl = INT2PTR(SSL *, stack_top);
        }
        else
            croak("ssl is not an Crypt::SSLeay::Conn")
;
#line 459 "SSLeay.xs"
        RETVAL = SSL_get_shared_ciphers(
                    ssl, buf, CRYPT_SSLEAY_SHARED_CIPHERS_BUFSIZE
                 );
#line 1021 "SSLeay.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Conn_get_cipher); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Conn_get_cipher)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ssl");
    {
	SSL*	ssl;
	char *	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::Conn")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ssl = INT2PTR(SSL *, stack_top);
        }
        else
            croak("ssl is not an Crypt::SSLeay::Conn")
;
#line 469 "SSLeay.xs"
           RETVAL = (char*) SSL_get_cipher(ssl);
#line 1048 "SSLeay.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_Crypt__SSLeay__Conn_set_tlsext_host_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Conn_set_tlsext_host_name)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "ssl, name");
    {
	SSL *	ssl;
	const char *	name = (const char *)SvPV_nolen(ST(1))
;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::Conn")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            ssl = INT2PTR(SSL *, stack_top);
        }
        else
            croak("ssl is not an Crypt::SSLeay::Conn")
;

	SSL_set_tlsext_host_name(ssl, name);
    }
    XSRETURN_EMPTY;
}

#endif

XS_EUPXS(XS_Crypt__SSLeay__X509_free); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__X509_free)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    {
	X509*	cert;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::X509")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            cert = INT2PTR(X509 *, stack_top);
        }
        else
            croak("cert is not an Crypt::SSLeay::X509")
;

	X509_free(cert);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Crypt__SSLeay__X509_subject_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__X509_subject_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    {
	X509*	cert;
#line 492 "SSLeay.xs"
           char* str;
#line 1117 "SSLeay.c"
	SV *	RETVAL;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::X509")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            cert = INT2PTR(X509 *, stack_top);
        }
        else
            croak("cert is not an Crypt::SSLeay::X509")
;
#line 494 "SSLeay.xs"
           str = X509_NAME_oneline(X509_get_subject_name(cert), NULL, 0);
           RETVAL = newSVpv(str, 0);
           CRYPT_SSLEAY_free(str);
#line 1131 "SSLeay.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__X509_issuer_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__X509_issuer_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    {
	X509*	cert;
#line 504 "SSLeay.xs"
           char* str;
#line 1149 "SSLeay.c"
	SV *	RETVAL;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::X509")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            cert = INT2PTR(X509 *, stack_top);
        }
        else
            croak("cert is not an Crypt::SSLeay::X509")
;
#line 506 "SSLeay.xs"
           str = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0);
           RETVAL = newSVpv(str, 0);
           CRYPT_SSLEAY_free(str);
#line 1163 "SSLeay.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__X509_get_notBeforeString); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__X509_get_notBeforeString)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    {
	X509*	cert;
	char *	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::X509")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            cert = INT2PTR(X509 *, stack_top);
        }
        else
            croak("cert is not an Crypt::SSLeay::X509")
;
#line 516 "SSLeay.xs"
            RETVAL = (char *)X509_get_notBefore(cert)->data;
#line 1191 "SSLeay.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__X509_get_notAfterString); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__X509_get_notAfterString)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    {
	X509*	cert;
	char *	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Crypt::SSLeay::X509")) {
            IV stack_top = SvIV((SV*)SvRV(ST(0)));
            cert = INT2PTR(X509 *, stack_top);
        }
        else
            croak("cert is not an Crypt::SSLeay::X509")
;
#line 524 "SSLeay.xs"
            RETVAL = (char *)X509_get_notAfter(cert)->data;
#line 1218 "SSLeay.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Version_openssl_version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Version_openssl_version)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const char *	RETVAL;
	dXSTARG;
#line 533 "SSLeay.xs"
        RETVAL = SSLeay_version(SSLEAY_VERSION);
#line 1236 "SSLeay.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Version_openssl_version_number); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Version_openssl_version_number)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	long	RETVAL;
	dXSTARG;
#line 540 "SSLeay.xs"
        RETVAL = OPENSSL_VERSION_NUMBER;
#line 1254 "SSLeay.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Version_openssl_cflags); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Version_openssl_cflags)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const char *	RETVAL;
	dXSTARG;
#line 547 "SSLeay.xs"
        RETVAL = SSLeay_version(SSLEAY_CFLAGS);
#line 1272 "SSLeay.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Version_openssl_platform); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Version_openssl_platform)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const char *	RETVAL;
	dXSTARG;
#line 554 "SSLeay.xs"
        RETVAL = SSLeay_version(SSLEAY_PLATFORM);
#line 1290 "SSLeay.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Version_openssl_built_on); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Version_openssl_built_on)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const char *	RETVAL;
	dXSTARG;
#line 561 "SSLeay.xs"
        RETVAL = SSLeay_version(SSLEAY_BUILT_ON);
#line 1308 "SSLeay.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Crypt__SSLeay__Version_openssl_dir); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Crypt__SSLeay__Version_openssl_dir)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const char *	RETVAL;
	dXSTARG;
#line 568 "SSLeay.xs"
        RETVAL = SSLeay_version(SSLEAY_DIR);
#line 1326 "SSLeay.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Crypt__SSLeay); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Crypt__SSLeay)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("Crypt::SSLeay::Err::get_error_string", XS_Crypt__SSLeay__Err_get_error_string);
        newXS_deffile("Crypt::SSLeay::CTX::new", XS_Crypt__SSLeay__CTX_new);
        newXS_deffile("Crypt::SSLeay::CTX::free", XS_Crypt__SSLeay__CTX_free);
        newXS_deffile("Crypt::SSLeay::CTX::set_cipher_list", XS_Crypt__SSLeay__CTX_set_cipher_list);
        newXS_deffile("Crypt::SSLeay::CTX::use_certificate_file", XS_Crypt__SSLeay__CTX_use_certificate_file);
        newXS_deffile("Crypt::SSLeay::CTX::use_PrivateKey_file", XS_Crypt__SSLeay__CTX_use_PrivateKey_file);
        newXS_deffile("Crypt::SSLeay::CTX::use_pkcs12_file", XS_Crypt__SSLeay__CTX_use_pkcs12_file);
        newXS_deffile("Crypt::SSLeay::CTX::check_private_key", XS_Crypt__SSLeay__CTX_check_private_key);
        newXS_deffile("Crypt::SSLeay::CTX::set_verify", XS_Crypt__SSLeay__CTX_set_verify);
        newXS_deffile("Crypt::SSLeay::Conn::new", XS_Crypt__SSLeay__Conn_new);
        newXS_deffile("Crypt::SSLeay::Conn::free", XS_Crypt__SSLeay__Conn_free);
        newXS_deffile("Crypt::SSLeay::Conn::pending", XS_Crypt__SSLeay__Conn_pending);
        newXS_deffile("Crypt::SSLeay::Conn::set_fd", XS_Crypt__SSLeay__Conn_set_fd);
        newXS_deffile("Crypt::SSLeay::Conn::connect", XS_Crypt__SSLeay__Conn_connect);
        newXS_deffile("Crypt::SSLeay::Conn::accept", XS_Crypt__SSLeay__Conn_accept);
        newXS_deffile("Crypt::SSLeay::Conn::write", XS_Crypt__SSLeay__Conn_write);
        newXS_deffile("Crypt::SSLeay::Conn::read", XS_Crypt__SSLeay__Conn_read);
        newXS_deffile("Crypt::SSLeay::Conn::get_peer_certificate", XS_Crypt__SSLeay__Conn_get_peer_certificate);
        newXS_deffile("Crypt::SSLeay::Conn::get_verify_result", XS_Crypt__SSLeay__Conn_get_verify_result);
        newXS_deffile("Crypt::SSLeay::Conn::get_shared_ciphers", XS_Crypt__SSLeay__Conn_get_shared_ciphers);
        newXS_deffile("Crypt::SSLeay::Conn::get_cipher", XS_Crypt__SSLeay__Conn_get_cipher);
#if XSubPPtmpAAAA
        newXS_deffile("Crypt::SSLeay::Conn::set_tlsext_host_name", XS_Crypt__SSLeay__Conn_set_tlsext_host_name);
#endif
        newXS_deffile("Crypt::SSLeay::X509::free", XS_Crypt__SSLeay__X509_free);
        newXS_deffile("Crypt::SSLeay::X509::subject_name", XS_Crypt__SSLeay__X509_subject_name);
        newXS_deffile("Crypt::SSLeay::X509::issuer_name", XS_Crypt__SSLeay__X509_issuer_name);
        newXS_deffile("Crypt::SSLeay::X509::get_notBeforeString", XS_Crypt__SSLeay__X509_get_notBeforeString);
        newXS_deffile("Crypt::SSLeay::X509::get_notAfterString", XS_Crypt__SSLeay__X509_get_notAfterString);
        newXS_deffile("Crypt::SSLeay::Version::openssl_version", XS_Crypt__SSLeay__Version_openssl_version);
        newXS_deffile("Crypt::SSLeay::Version::openssl_version_number", XS_Crypt__SSLeay__Version_openssl_version_number);
        newXS_deffile("Crypt::SSLeay::Version::openssl_cflags", XS_Crypt__SSLeay__Version_openssl_cflags);
        newXS_deffile("Crypt::SSLeay::Version::openssl_platform", XS_Crypt__SSLeay__Version_openssl_platform);
        newXS_deffile("Crypt::SSLeay::Version::openssl_built_on", XS_Crypt__SSLeay__Version_openssl_built_on);
        newXS_deffile("Crypt::SSLeay::Version::openssl_dir", XS_Crypt__SSLeay__Version_openssl_dir);

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#line 1400 "SSLeay.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

